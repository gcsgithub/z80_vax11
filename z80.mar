    .title z80-emulator
    .ident /160989/
;
; (c) Copyright 1989 Mark Garrett
;
;     You may use this program freely, You may not sell it. If you improve or change this program in
; any way I'd appreciate that you send me your changes, and make proper comments in the source code indicating the changes.
;
;    I MAKE NO REPRESENTATIONS ABOUT THE SUITABILITY OF
;    THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" 
;
;    WITH OUT EXPRESSED OR IMPLIED WARRANTY OF ANY KIND.
;    I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE,
;    INCLUDING ALL IMPLIED WARRANTES OF MERCHANTABILITY AND FITNESS
;    FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL I, BE LIABLE FOR ANY 
;    SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
;    OR PROFITS, WHETHER IN ANY ACTION OF CONTRACT, NEGLIGENCE
;    OR OTHER TORTIOUS ACTION, ARISING OUT OF OR INCONNECTION
;    WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
;
;    I hope that covers the copyright bit. I knew I should have
;    gone to law school but computers seem more fun..
;
; 2013 fix long standing error in pun and rdr rabs
;       add support for halt loop with prompt to exit, incomplete
; 2016 fix typos and get this working again
; 2017 hmm at least one my typo from the listing ^D instead of ^XD
;      more fixing
; 2017 lets get macro-ed
;
;
; This program will emulate a micro computer based on :-
; CPU   = z80
; OS    = CP/M
; CRT   = ANSI (vt100)
;
;
$iodef
$ttdef
$ssdef
;$lnmdef

.macro   defstr  nam, len
$EQU	'nam'$S_LEN	len
'nam'_dsc:
'nam':
'nam'_len:      .word    len
                .byte    DSC$K_DTYPE_T
                .byte    DSC$K_CLASS_S
'nam'_addr:     .address 'nam'_str
'nam'_str:	.blkb    len
.endm

            .psect z80$FILE_CONTROL    LONG,WRT,noexe
;
;
OUT$FAB:    $FAB    FAC=<PUT>        ,-
                    RFM=<VAR>        ,-
                    SHR=<GET>        ,-
                    FNM=<SYS$OUTPUT>
;
OUT$RAB:    $RAB    FAB=OUT$FAB      ,-
                    RAC=<SEQ>        ,-
                    RBF=outbuf_str   ,-
                    RSZ=outbuf$S_LEN ,-
                    UBF=outbuf_str   ,-
                    USZ=outbuf$S_LEN
;
pun$FAB:    $FAB    FAC=<PUT>        ,-
                    RFM=<VAR>        ,-
                    SHR=<GET>        ,-
                    FNM=<z80$pun>
;
pun$RAB:    $RAB    FAB=pun$FAB      ,-
                    RAC=<SEQ>        ,-
                    RBF=pun$rec      ,-
                    RSZ=256          ,-
                    UBF=pun$rec      ,-
                    USZ=256
;
rdr$FAB:    $FAB    FAC=<GET>        ,-
                    RFM=<VAR>        ,-
                    SHR=<GET>        ,-
                    FNM=<z80$rdr>
;
rdr$RAB:    $RAB    FAB=rdr$FAB      ,-
                    RAC=<SEQ>        ,-
                    RBF=rdr$rec      ,-
                    RSZ=256          ,-
                    UBF=rdr$rec      ,-
                    USZ=256
;
lpt$FAB:    $FAB    FAC=<PUT>        ,-
                    RFM=<VAR>        ,-
                    SHR=<GET>        ,-
                    FNM=<z80$lpt>
;
lpt$RAB:    $RAB    FAB=lpt$FAB      ,-
                    RAC=<SEQ>        ,-
                    RBF=lpt$rec      ,-
                    RSZ=132          ,-
                    UBF=lpt$rec      ,-
                    USZ=132
;
boot$FAB:   $FAB    FAC=<GET>        ,-
                    RFM=<VAR>        ,-
                    SHR=<GET>        ,-
                    FNM=<z80$boot>   ; bootrom.hex
;
; boot record is in IntelHex format which means a max length
; of 1+2+4+2+255*2+2 = 521 + lineterminators so use 1024
boot$RAB:    $RAB   FAB=boot$FAB     ,-
                    RAC=<SEQ>        ,-
                    RBF=bootrec_str  ,-
                    RSZ=bootrec$S_LEN,-
                    UBF=bootrec_str  ,-
                    USZ=bootrec$S_LEN
;
drive_A$FAB: $FAB   FAC=<PUT,GET,UPD>,-
                    SHR=<GET>        ,-
                    ORG=<REL>        ,-
                    RFM=<FIX>        ,-
                    FNM=<z80$drive_a>    ; assign logical
;
drive_A$RAB: $RAB   FAB=drive_A$FAB  ,-
                    RAC=<KEY>        ,-
                    KRF=0            ,-
                    KBF=REC_NO       ,-
                    KSZ=4            ,-
                    RBF=DRIVEA_REC   ,-
                    RSZ=128          ,-
                    UBF=DRIVEA_REC   ,-
                    USZ=128

REC128_TRK==37

        .psect z80$strings    LONG,rd,nowrt,noexe
dump_z80_reg_msg_dsc:   .ascid -
" Z80PC = !4XW (!XB)!/"-
"    AF = !4XW !AS      AF' = !4XW !AS!/"-
"    BC = !4XW (!XB)          BC' = !4XW (!XB)!/"-
"    DE = !4XW (!XB)          DE' = !4XW (!XB)!/"-
"    HL = !4XW (!XB)          HL' = !4XW (!XB)!/"-
"        IX = !4XW (!XB)!/"-
"        IY = !4XW (!XB)!/"-
"        SP = !4XW (!4XW:!4XW, !4XW:!4XW, !4XW:!4XW)!/"-
"        IR = !4XW!/"

loaded_dsc:         .ascid "Loaded @!4XW (!XB)!/"
err_unknown_op_dsc: .ascid "Unknown opcode !2XB!/"

hex16_dsc:          .ascid "!4XW "
hex8_dsc:           .ascid "!2XB "
halt_prompt_dsc:    .ascid "Press Return to Continue"
chksum_error_dsc:   .ascid "Checksum error expected !2XB got !2XB!/"
noextmem_error_dsc: .ascid "Attempt to store into non-existant memory @!2XB!/"



        .psect file$data    rd, wrt, noexe
REC_NO:            .blkl     1
lptptr:            .blkw     1
punptr:            .blkw     1
rdrptr:            .blkw     1

lpt$rec:           .blkb     256
pun$rec:           .blkb     256
rdr$rec:           .blkb     256
drivea_rec:        .blkb   128

z80Flagm_C       ==    ^X01
z80Flagm_SUBN    ==    ^X02
z80Flagm_PV      ==    ^X04
z80Flagm_3       ==    ^X08
z80Flagm_H       ==    ^X10
z80Flagm_5       ==    ^X20
z80Flagm_Z       ==    ^X40
z80Flagm_S       ==    ^X80

z80Flagb_C       ==    0
z80Flagb_SUBN    ==    1
z80Flagb_PV      ==    2
z80Flagb_3       ==    3
z80Flagb_H       ==    4
z80Flagb_5       ==    5
z80Flagb_Z       ==    6
z80Flagb_S       ==    7


z80Flagm_CN      ==      z80Flagm_C!z80Flagm_SUBN 
z80Flagm_HN      ==      z80Flagm_H!z80Flagm_SUBN 
z80Flagm_ZN      ==      z80Flagm_Z!z80Flagm_SUBN 
z80Flagm_SN      ==      z80Flagm_S!z80Flagm_SUBN 

vaxFlag_C       == 0
vaxFlag_V       == 1
vaxFlag_Z       == 2
vaxFlag_N       == 3 ; reverse of z80 which is 0=+ve 1=-ve
vaxFlag_T       == 4
vaxFlag_IV      == 5
vaxFlag_FU      == 6
vaxFlag_DV      == 7
vaxFlag_Unused1 == 8
vaxFlag_Unused2 == 9
vaxFlag_Unused3 == 10
vaxFlag_Unused4 == 11
vaxFlag_Unused5 == 12
vaxFlag_Unused6 == 13
vaxFlag_Unused7 == 14
vaxFlag_Unused8 == 15
vaxFlag_IPL0    == 16
vaxFlag_IPL1    == 17
vaxFlag_IPL2    == 18
vaxFlag_IPL3    == 19
vaxFlag_IPL4    == 20
; 21-29 others
vaxFlag_TP      == 30
vaxFlag_CM      == 31




        .psect z80$data    noexe,rd,wrt,pic

qio_flag:            .blkb    1

tt_nam:              .ascid /Z80$TERM/
tt_chan:             .blkw    1
tt_iosb:             .blkq    1
tt_buf:              .blkb    1
save_reg:            .blkl    1


emucons_nam:        .ascid /Z80$CONSOLE/
emucons_chan:       .blkw    1
emucons_iosb:       .blkq    1
emucons_iochar:     .blkb    1

iochar:             .blkb    1


;save_key:          .blkb    1
defstr	           flag1,   8 
defstr             flag2,   8
defstr             bootrec, 1024
defstr             outbuf, 2000 ; 80*25

runflag:           .long   0           ; run while 0
brkflag:           .long   0           ; run while 0
intflg:            .byte   ^xff        ; 0xff int enabled



             .psect z80$registers    noexe,rd,wrt,pic,long
ptr_AF:      .address    reg_AF
ptr_BC:      .address    reg_BC ; 00
ptr_DE:      .address    reg_DE ; 01
ptr_IDX:     .address    reg_HL ; 10
ptr_SP:      .address    reg_SP ; 11

ptrn_BC:     .address    reg_BC ; 00
ptrn_DE:     .address    reg_DE ; 01
ptrn_HL:     .address    reg_HL ; 10
ptrn_AF:     .address    reg_AF ; 11


reg_AF:
    reg_F:   .blkb    1
    reg_A:   .blkb    1
reg_BC:
    reg_C:   .blkb    1
    reg_B:   .blkb    1
reg_DE:
    reg_E:   .blkb    1
    reg_D:   .blkb    1
reg_HL:
    reg_L:   .blkb    1
    reg_H:   .blkb    1


reg_AF2:
    reg_F2:  .blkb    1
    reg_A2:  .blkb    1
reg_BC2:
    reg_C2:  .blkb    1
    reg_B2:  .blkb    1
reg_DE2:
    reg_E2:  .blkb    1
    reg_D2:  .blkb    1
reg_HL2:
    reg_L2:  .blkb    1
    reg_H2:  .blkb    1

reg_SP:
    reg_SPL: .blkb   1
    reg_SPH: .blkb   1
reg_IX:
    reg_IXL: .blkb   1
    reg_IXH: .blkb   1
reg_IY:
    reg_IYL: .blkb   1
    reg_IYH: .blkb   1

reg_IR:
    reg_R:  .blkb    1
    reg_I:  .blkb    1

CURIPADDR:  .long    0         ; current instruction pointer
CURIP:      .word    0
NEW_PC:     .blkw    1
TEMP:       .blkw    1
DMPTMP:     .blkw    1

DFLG:       .long    0  ; what to trace dis and or dump
TRACEDEPTH: .long    0
CALLDEPTH:  .long    0
DOTS:	    .long    0  ; !=0 need newline
ID:         .word    ^A/ID/

;int envval( char *str, int len , char *buf)
ID_LEN:	    .long   254
ID_BUF:     .blkb   255
ID_NAM:	    .asciz  "Z80$TRACEORDER" ; Instruction Data

CHKSUM:     .byte    0

save_key == ^x0DF60
;;;;;;;;;;;;;;;;;;;;;;;;;;
z80_memory:     .blkb ^xffff
z80_mem_prot:   .blkb ^xffff ; lbs exists !=0   01=read, 10=write, 11=read+writeable  (256 byte pages)
;;;;;;;;;;;;;;;;;;;;;;;;;;

             .psect z80$constants    noexe,rd,nowrt,pic,long
parity_mask:    
        .byte   ^O004   ; 00000000: EVEN
        .byte   ^O000   ; 00000001: ODD
        .byte   ^O000   ; 00000002: ODD
        .byte   ^O004   ; 00000003: EVEN
        .byte   ^O000   ; 00000004: ODD
        .byte   ^O004   ; 00000005: EVEN
        .byte   ^O004   ; 00000006: EVEN
        .byte   ^O000   ; 00000007: ODD
        .byte   ^O000   ; 00000008: ODD
        .byte   ^O004   ; 00000009: EVEN
        .byte   ^O004   ; 0000000A: EVEN
        .byte   ^O000   ; 0000000B: ODD
        .byte   ^O004   ; 0000000C: EVEN
        .byte   ^O000   ; 0000000D: ODD
        .byte   ^O000   ; 0000000E: ODD
        .byte   ^O004   ; 0000000F: EVEN
        .byte   ^O000   ; 00000010: ODD
        .byte   ^O004   ; 00000011: EVEN
        .byte   ^O004   ; 00000012: EVEN
        .byte   ^O000   ; 00000013: ODD
        .byte   ^O004   ; 00000014: EVEN
        .byte   ^O000   ; 00000015: ODD
        .byte   ^O000   ; 00000016: ODD
        .byte   ^O004   ; 00000017: EVEN
        .byte   ^O004   ; 00000018: EVEN
        .byte   ^O000   ; 00000019: ODD
        .byte   ^O000   ; 0000001A: ODD
        .byte   ^O004   ; 0000001B: EVEN
        .byte   ^O000   ; 0000001C: ODD
        .byte   ^O004   ; 0000001D: EVEN
        .byte   ^O004   ; 0000001E: EVEN
        .byte   ^O000   ; 0000001F: ODD
        .byte   ^O000   ; 00000020: ODD
        .byte   ^O004   ; 00000021: EVEN
        .byte   ^O004   ; 00000022: EVEN
        .byte   ^O000   ; 00000023: ODD
        .byte   ^O004   ; 00000024: EVEN
        .byte   ^O000   ; 00000025: ODD
        .byte   ^O000   ; 00000026: ODD
        .byte   ^O004   ; 00000027: EVEN
        .byte   ^O004   ; 00000028: EVEN
        .byte   ^O000   ; 00000029: ODD
        .byte   ^O000   ; 0000002A: ODD
        .byte   ^O004   ; 0000002B: EVEN
        .byte   ^O000   ; 0000002C: ODD
        .byte   ^O004   ; 0000002D: EVEN
        .byte   ^O004   ; 0000002E: EVEN
        .byte   ^O000   ; 0000002F: ODD
        .byte   ^O004   ; 00000030: EVEN
        .byte   ^O000   ; 00000031: ODD
        .byte   ^O000   ; 00000032: ODD
        .byte   ^O004   ; 00000033: EVEN
        .byte   ^O000   ; 00000034: ODD
        .byte   ^O004   ; 00000035: EVEN
        .byte   ^O004   ; 00000036: EVEN
        .byte   ^O000   ; 00000037: ODD
        .byte   ^O000   ; 00000038: ODD
        .byte   ^O004   ; 00000039: EVEN
        .byte   ^O004   ; 0000003A: EVEN
        .byte   ^O000   ; 0000003B: ODD
        .byte   ^O004   ; 0000003C: EVEN
        .byte   ^O000   ; 0000003D: ODD
        .byte   ^O000   ; 0000003E: ODD
        .byte   ^O004   ; 0000003F: EVEN
        .byte   ^O000   ; 00000040: ODD
        .byte   ^O004   ; 00000041: EVEN
        .byte   ^O004   ; 00000042: EVEN
        .byte   ^O000   ; 00000043: ODD
        .byte   ^O004   ; 00000044: EVEN
        .byte   ^O000   ; 00000045: ODD
        .byte   ^O000   ; 00000046: ODD
        .byte   ^O004   ; 00000047: EVEN
        .byte   ^O004   ; 00000048: EVEN
        .byte   ^O000   ; 00000049: ODD
        .byte   ^O000   ; 0000004A: ODD
        .byte   ^O004   ; 0000004B: EVEN
        .byte   ^O000   ; 0000004C: ODD
        .byte   ^O004   ; 0000004D: EVEN
        .byte   ^O004   ; 0000004E: EVEN
        .byte   ^O000   ; 0000004F: ODD
        .byte   ^O004   ; 00000050: EVEN
        .byte   ^O000   ; 00000051: ODD
        .byte   ^O000   ; 00000052: ODD
        .byte   ^O004   ; 00000053: EVEN
        .byte   ^O000   ; 00000054: ODD
        .byte   ^O004   ; 00000055: EVEN
        .byte   ^O004   ; 00000056: EVEN
        .byte   ^O000   ; 00000057: ODD
        .byte   ^O000   ; 00000058: ODD
        .byte   ^O004   ; 00000059: EVEN
        .byte   ^O004   ; 0000005A: EVEN
        .byte   ^O000   ; 0000005B: ODD
        .byte   ^O004   ; 0000005C: EVEN
        .byte   ^O000   ; 0000005D: ODD
        .byte   ^O000   ; 0000005E: ODD
        .byte   ^O004   ; 0000005F: EVEN
        .byte   ^O004   ; 00000060: EVEN
        .byte   ^O000   ; 00000061: ODD
        .byte   ^O000   ; 00000062: ODD
        .byte   ^O004   ; 00000063: EVEN
        .byte   ^O000   ; 00000064: ODD
        .byte   ^O004   ; 00000065: EVEN
        .byte   ^O004   ; 00000066: EVEN
        .byte   ^O000   ; 00000067: ODD
        .byte   ^O000   ; 00000068: ODD
        .byte   ^O004   ; 00000069: EVEN
        .byte   ^O004   ; 0000006A: EVEN
        .byte   ^O000   ; 0000006B: ODD
        .byte   ^O004   ; 0000006C: EVEN
        .byte   ^O000   ; 0000006D: ODD
        .byte   ^O000   ; 0000006E: ODD
        .byte   ^O004   ; 0000006F: EVEN
        .byte   ^O000   ; 00000070: ODD
        .byte   ^O004   ; 00000071: EVEN
        .byte   ^O004   ; 00000072: EVEN
        .byte   ^O000   ; 00000073: ODD
        .byte   ^O004   ; 00000074: EVEN
        .byte   ^O000   ; 00000075: ODD
        .byte   ^O000   ; 00000076: ODD
        .byte   ^O004   ; 00000077: EVEN
        .byte   ^O004   ; 00000078: EVEN
        .byte   ^O000   ; 00000079: ODD
        .byte   ^O000   ; 0000007A: ODD
        .byte   ^O004   ; 0000007B: EVEN
        .byte   ^O000   ; 0000007C: ODD
        .byte   ^O004   ; 0000007D: EVEN
        .byte   ^O004   ; 0000007E: EVEN
        .byte   ^O000   ; 0000007F: ODD
        .byte   ^O000   ; 00000080: ODD
        .byte   ^O004   ; 00000081: EVEN
        .byte   ^O004   ; 00000082: EVEN
        .byte   ^O000   ; 00000083: ODD
        .byte   ^O004   ; 00000084: EVEN
        .byte   ^O000   ; 00000085: ODD
        .byte   ^O000   ; 00000086: ODD
        .byte   ^O004   ; 00000087: EVEN
        .byte   ^O004   ; 00000088: EVEN
        .byte   ^O000   ; 00000089: ODD
        .byte   ^O000   ; 0000008A: ODD
        .byte   ^O004   ; 0000008B: EVEN
        .byte   ^O000   ; 0000008C: ODD
        .byte   ^O004   ; 0000008D: EVEN
        .byte   ^O004   ; 0000008E: EVEN
        .byte   ^O000   ; 0000008F: ODD
        .byte   ^O004   ; 00000090: EVEN
        .byte   ^O000   ; 00000091: ODD
        .byte   ^O000   ; 00000092: ODD
        .byte   ^O004   ; 00000093: EVEN
        .byte   ^O000   ; 00000094: ODD
        .byte   ^O004   ; 00000095: EVEN
        .byte   ^O004   ; 00000096: EVEN
        .byte   ^O000   ; 00000097: ODD
        .byte   ^O000   ; 00000098: ODD
        .byte   ^O004   ; 00000099: EVEN
        .byte   ^O004   ; 0000009A: EVEN
        .byte   ^O000   ; 0000009B: ODD
        .byte   ^O004   ; 0000009C: EVEN
        .byte   ^O000   ; 0000009D: ODD
        .byte   ^O000   ; 0000009E: ODD
        .byte   ^O004   ; 0000009F: EVEN
        .byte   ^O004   ; 000000A0: EVEN
        .byte   ^O000   ; 000000A1: ODD
        .byte   ^O000   ; 000000A2: ODD
        .byte   ^O004   ; 000000A3: EVEN
        .byte   ^O000   ; 000000A4: ODD
        .byte   ^O004   ; 000000A5: EVEN
        .byte   ^O004   ; 000000A6: EVEN
        .byte   ^O000   ; 000000A7: ODD
        .byte   ^O000   ; 000000A8: ODD
        .byte   ^O004   ; 000000A9: EVEN
        .byte   ^O004   ; 000000AA: EVEN
        .byte   ^O000   ; 000000AB: ODD
        .byte   ^O004   ; 000000AC: EVEN
        .byte   ^O000   ; 000000AD: ODD
        .byte   ^O000   ; 000000AE: ODD
        .byte   ^O004   ; 000000AF: EVEN
        .byte   ^O000   ; 000000B0: ODD
        .byte   ^O004   ; 000000B1: EVEN
        .byte   ^O004   ; 000000B2: EVEN
        .byte   ^O000   ; 000000B3: ODD
        .byte   ^O004   ; 000000B4: EVEN
        .byte   ^O000   ; 000000B5: ODD
        .byte   ^O000   ; 000000B6: ODD
        .byte   ^O004   ; 000000B7: EVEN
        .byte   ^O004   ; 000000B8: EVEN
        .byte   ^O000   ; 000000B9: ODD
        .byte   ^O000   ; 000000BA: ODD
        .byte   ^O004   ; 000000BB: EVEN
        .byte   ^O000   ; 000000BC: ODD
        .byte   ^O004   ; 000000BD: EVEN
        .byte   ^O004   ; 000000BE: EVEN
        .byte   ^O000   ; 000000BF: ODD
        .byte   ^O004   ; 000000C0: EVEN
        .byte   ^O000   ; 000000C1: ODD
        .byte   ^O000   ; 000000C2: ODD
        .byte   ^O004   ; 000000C3: EVEN
        .byte   ^O000   ; 000000C4: ODD
        .byte   ^O004   ; 000000C5: EVEN
        .byte   ^O004   ; 000000C6: EVEN
        .byte   ^O000   ; 000000C7: ODD
        .byte   ^O000   ; 000000C8: ODD
        .byte   ^O004   ; 000000C9: EVEN
        .byte   ^O004   ; 000000CA: EVEN
        .byte   ^O000   ; 000000CB: ODD
        .byte   ^O004   ; 000000CC: EVEN
        .byte   ^O000   ; 000000CD: ODD
        .byte   ^O000   ; 000000CE: ODD
        .byte   ^O004   ; 000000CF: EVEN
        .byte   ^O000   ; 000000D0: ODD
        .byte   ^O004   ; 000000D1: EVEN
        .byte   ^O004   ; 000000D2: EVEN
        .byte   ^O000   ; 000000D3: ODD
        .byte   ^O004   ; 000000D4: EVEN
        .byte   ^O000   ; 000000D5: ODD
        .byte   ^O000   ; 000000D6: ODD
        .byte   ^O004   ; 000000D7: EVEN
        .byte   ^O004   ; 000000D8: EVEN
        .byte   ^O000   ; 000000D9: ODD
        .byte   ^O000   ; 000000DA: ODD
        .byte   ^O004   ; 000000DB: EVEN
        .byte   ^O000   ; 000000DC: ODD
        .byte   ^O004   ; 000000DD: EVEN
        .byte   ^O004   ; 000000DE: EVEN
        .byte   ^O000   ; 000000DF: ODD
        .byte   ^O000   ; 000000E0: ODD
        .byte   ^O004   ; 000000E1: EVEN
        .byte   ^O004   ; 000000E2: EVEN
        .byte   ^O000   ; 000000E3: ODD
        .byte   ^O004   ; 000000E4: EVEN
        .byte   ^O000   ; 000000E5: ODD
        .byte   ^O000   ; 000000E6: ODD
        .byte   ^O004   ; 000000E7: EVEN
        .byte   ^O004   ; 000000E8: EVEN
        .byte   ^O000   ; 000000E9: ODD
        .byte   ^O000   ; 000000EA: ODD
        .byte   ^O004   ; 000000EB: EVEN
        .byte   ^O000   ; 000000EC: ODD
        .byte   ^O004   ; 000000ED: EVEN
        .byte   ^O004   ; 000000EE: EVEN
        .byte   ^O000   ; 000000EF: ODD
        .byte   ^O004   ; 000000F0: EVEN
        .byte   ^O000   ; 000000F1: ODD
        .byte   ^O000   ; 000000F2: ODD
        .byte   ^O004   ; 000000F3: EVEN
        .byte   ^O000   ; 000000F4: ODD
        .byte   ^O004   ; 000000F5: EVEN
        .byte   ^O004   ; 000000F6: EVEN
        .byte   ^O000   ; 000000F7: ODD
        .byte   ^O000   ; 000000F8: ODD
        .byte   ^O004   ; 000000F9: EVEN
        .byte   ^O004   ; 000000FA: EVEN
        .byte   ^O000   ; 000000FB: ODD
        .byte   ^O004   ; 000000FC: EVEN
        .byte   ^O000   ; 000000FD: ODD
        .byte   ^O000   ; 000000FE: ODD
        .byte   ^O004   ; 000000FF: EVEN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            .psect    z80$emulator    exe,nowrt,pic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Z80_START:: .word ^M<>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;    R9 holds address of HL reg pair
;    r1 holds the memory address last accessed when looping back to fetch
; ZPC=R10
; zmem=R11
            movab   z80_memory, r11
            bsbw    z80config
            clrw    reg_SP
            movaw   reg_HL,    r9
            movzwl  #^x0100,   r10   ; for testing start at 0100h
            bisb2   #^x80,     reg_R ; set the high bit 
	    clrb    tt_buf

	    clrl    CALLDEPTH
	    clrl    TRACEDEPTH
	    clrl    DFLG

            calls   #0, ISDBG
            movl    r0, DFLG

            calls   #0, ISTRACE
            movl    r0, TRACEDEPTH


            movc5   #0, ID_BUF  , #0, ID_LEN, ID_BUF
	    pushab  ID_BUF
	    pushl   ID_LEN
	    pushab  ID_NAM
            calls   #3, envval  ;int envval( char *str, int len , char *buf)
            movb    ID_BUF+1, ID
            movb    ID_BUF  , ID+1
;;;;;;
fetch:
;;;;;;
            blbc    brkflag, exec0
breakpoint: clrb    brkflag
            bsbw    dump_z80_reg

exec0:
            movaw   reg_HL, ptr_IDX
            addb3   reg_R, #1, r0 ; increment 7bits of R
            bicb2   #^x80, r0     ; clear high bit
            bicb2   #^x7f, reg_R  ; clear the low bits of R
            bisb2   r0,    reg_R  ; add the 7bits of add back

fetch2:     
            movzbl  (r10)[r11], r0
            movw    r10, CURIP
            movab   (r10)[r11], CURIPADDR

            blbc    runflag, fetched
            brw     halt

fetched:
            bsbw    traceit
;
fetch0:
            incw    r10           ; inc z80pc
;   
            extzv   #0, #3, r0, r2
            extzv   #6, #2, r0, r1

            caseb   r1, #0, #3  ; 00 01 10 11
               10$: .word   op00-10$
                    .word   op01-10$
                    .word   op10-10$
                    .word   op11-10$
	    ; fall through for 0 to op00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
op00:       caseb   r2, #0, #7              ;
               10$: .word op00___000-10$    ; nop, ex, djnz and jr
                    .word op00___001-10$    ; LD/ADD HL rr??
                    .word op00___010-10$    ; various loads
                    .word op00___011-10$    ; INC/DEC rr
                    .word op00___100-10$    ; INC r eflags: SZ5H3VN-
                    .word op00___101-10$    ; DEC r eflags: SZ5H3VN-
                    .word op00___110-10$    ; LD r, n
                    .word op00___111-10$    ; RLCA,RRCA,RLA,RRA,DAA,CPL,SCF,CCF
            brw   unknown_op                ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;
op00___000: extzv   #3, #3, r0, r1
;;;;;;;;;;;
            movzbl  (r10)[r11], r3          ; fetch branch value
            incw    r10

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r1, #0, #7              ;
               10$: .word op00_000_000-10$  ; NOP
                    .word op00_001_000-10$  ; EX AF, AF'
                    .word op00_010_000-10$  ; DJNZ  e
                    .word op00_011_000-10$  ; JR    e
                    .word op00_100_000-10$  ; JR    NZ, e
                    .word op00_101_000-10$  ; JR     Z, e
                    .word op00_110_000-10$  ; JR    NC, e
                    .word op00_111_000-10$  ; JR     C, e
            brw   unknown_op                ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op00_000_000:                     ; NOP
            decw    r10 ; restore r10 branch not part of NOP
            brw     fetch

op00_001_000:   ; EX AF, AF'
            decw    r10 ; restore r10 branch not part of EX
            movzwl  reg_AF, r0
            movw    reg_AF2, reg_AF
            movw    r0, reg_AF2
            brw     fetch

op00_010_000:   ; DJNZ e
            decb    reg_B
            beql    lab01   ; branch if loop is finished
op00_011_000:   ; JR    e
            addb2   r3, r10
lab01:      brw     fetch


op00_100_000:   ; JR    NZ, e
            bbc     #z80Flagb_Z, reg_F, op00_011_000
            brw     fetch
op00_101_000:   ; JR    Z, e
            bbs     #z80Flagb_Z, reg_F, op00_011_000
            brw     fetch
        
op00_110_000:   ; JR    NC, e
            blbc    reg_F, op00_011_000
            brw     fetch
op00_111_000:   ; JR     C, e
            blbs    reg_F, op00_011_000
            brw     fetch
                
        
;;;;;;;;;;;;;;;;;;;;;;;;
op00___001: ; op00rrx001
;;;;;;;;;;;;;;;;;;;;;;;;
	    extzv   #4, #2, r0, r3          ; 16 bit load literals
            bbs     #3, r0, ADD_rr16bit
LD_rr16bit: ; LD rr, nnnn                   op00_rr0_001
	    ; fetch word from PC

            movl    ptr_BC[r3], r2          ; 00=BC, 01=DE, 10=HL/IX/IY, 11=SP

            movb    (r10)[r11], (r2)+
            incw    r10
            movb    (r10)[r11], (r2)
            incw    r10

            brw     fetch
            
ADD_rr16bit: ;                               op00_rr1_001
	    ; ADD HL, rr or ADD IX, rr or ADD IY, rr
            ; --***-0C  F5,H,F3 from higher bytes addition
            ; H is set by a carry from bit 11 TODO: set H properly
            ; N is cleared
            ; C is set by carry from bit 15, reset otherwise
            bicb2   #^x3B     , reg_F       ; clear flags --5H3-NC
            bicb2   #z80Flagm_S, reg_F      ; +ve is S = 0

            movl    ptr_BC[r3], r2          ; BC, DE, HL, SP

            addw2   (r2), @ptr_IDX

            bcc     10$
            bisb2   #z80Flagm_C, reg_F      ; or carry into flags
    10$:    brw     fetch

;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___010: ; op00_xxy_010
;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; xx
            ; 00 = LD    (BC, DE), A
            ; 01 = LD A, (BC, DE)
            ; y direction
            ;
            ; 10 = LD (nnnn), HL / LD HL, (nnnn)
            ; 11 = LD (nnnn), A  / LD A , (nnnn)
            ; need an address either register contents else nnnn  in r4
            ; with an address of a register in r2

            
            extzv   #4, #2, r0, r3          ; bc/de index when used
            bbs     #3, r0, dst_regA
  ;bit3=0:
               ; dst is (bc) (de) or (nnnn)
               movl    ptr_BC[r3], r1       ; assume (BC) (DE) pointer in r1
               movzwl  (r1),       r1       ; the value  of the register in r1
	       bbc     #5, r0, 10$          ; branch if it is (BC) (DE)
		  ; else load (nnnn)
     		  movb    (r10)[r11], TEMP     ; fetch nnnn to TEMP
                  incw    r10
                  movb    (r10)[r11], TEMP+1
                  incw    r10
                  movzwl  TEMP, r1             ; get the 16bit address in r1
                  bbc #4, r0, 15$ ; dst16bitnnnn
               10$:
                  ; at this point r1 is a z80 address
                  movb    reg_A, (r1)[r11]
                  brw     fetch

               15$:  ; dst16bitnnnn: (r1) is the dst still (nnnn)

		  movl ptr_IDX, r2
		  movb (r2)+, (r1)[r11]
		  incw  r1
		  movb (r2) , (r1)[r11]
                  brw     fetch

   dst_regA: ; its dst A or HL
  ;bit3=1:
               ;
               ; src is (bc) (de) or (nnnn)
               movl    ptr_BC[r3], r1       ; assume (BC) (DE) pointer in r1
               movzwl  (r1),       r1       ; the value  of the register in r1
               bbc     #5, r0, 10$          ; branch if it is (BC) (DE)
               ;bit5=1
                  ; else load (nnnn)
                  movb    (r10)[r11], TEMP     ; fetch nnnn to TEMP
                  incw    r10
                  movb    (r10)[r11], TEMP+1
                  incw    r10
                  movzwl  TEMP, r1             ; get the 16bit address in r1
                  bbc #4, r0, 15$ ; src16bitnnnn
               10$:
                  ; at this point r1 is a z80 address
                  movb    (r1)[r11], reg_A
                  brw     fetch

               15$:  ; src16bitnnnn: (r1) is the src still (nnnn)

                  movl ptr_IDX, r2
                  movb (r1)[r11], (r2)+
                  incw  r1
                  movb (r1)[r11], (r2)
                  brw     fetch 


;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___011:
;;;;;;;;;;;;;;;;;;;;;;;;;;
            extzv   #4, #2, r0, r3          ; INC/DEC rr
            movl    ptr_BC[r3], r2          ; BC, DE, HL/IX/IY SP
            bbs     #3, r0, DECrr
            incw    (r2)
            brw     fetch
DECrr:      decw    (r2)
            brw     fetch
            
;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___100:                                   ; INC r
;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; eflags: SZ5H3VN-

            bsbw    XXrrrxxx
            movzbl  (r2), r1                ; keep a copy of pre-incremented
            incb    (r2)                    ; do the inc

            movpsl  r5
            ; eflags: SZ5H3VN-
            bicb2   #^xD6, reg_F
            bicb2   #z80Flagm_S, reg_F      ; clear S +ve

            bbc     #vaxFlag_V, r5, 21$
            bisb2   #z80Flagm_PV, reg_F     ; set V flag

    21$:    bbc     #vaxFlag_Z, r5, 33$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:
            bicb2   #^xF0, r1               ; clear upper nibble
            incb    r1
	    cmpzv   #4, #4, r1, #0          ; Check for half carry look for non-zero in
            beql    40$                     ; branch if no half carry
            bisb2   #z80Flagm_H, reg_F      ; set H flag
    40$:    brw     fetch
    
;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___101:                                   ; DEC r
;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; eflags: SZ5H3VN-
            bsbw    XXrrrxxx
            movzbl  (r2), r1                ; save value for Hcarry tst
            decb    (r2)                    ; do the dec

            movpsl  r5
            bicb2   #^xD6, reg_F            ; clear S, Z, H, V, N Flags
    	    bicb2   #z80Flagm_S,    reg_F
            bisb2   #z80Flagm_SUBN, reg_F  ; set N flag - substract op

            bbc     #vaxFlag_V, r5, 21$
            bisb2   #z80Flagm_PV, reg_F     ; set V flag

    21$:    bbc     #vaxFlag_Z, r5, 33$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    bicb2   #^xf0, r1               ; clear upper nibble
            decb    r1
            bicb2   #^x0f, r1
            tstb    r1
            bleq    42$                     ; branch if no half carry
            bisb2   #z80Flagm_H, reg_F      ; set H flag
    42$:    brw     fetch
    
;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___110:                                 ; LD r, n
;;;;;;;;;;;;;;;;;;;;;;;;;;
            bsbw    XXrrrxxx

            movb    (r10)[r11], (r2)        ; fetch n and store
            incw    r10

            brw     fetch
            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
op00___111: ; RLCA, RRCA, RLA, RRA, DAA, CPL, SCF, CCF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; eflags: RLCA/RLA/RRCA/RRA     --503-0C
            ; eflags: RLC/RL/RRC/RR r       SZ503P0C
            ;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            extzv   #3, #3, r0, r2             ;
            caseb   r2, #0, #7                 ;
    10$:        .word   op00_000_111-10$       ; RLCA eflags: --503-0C
                .word   op00_001_111-10$       ; RRCA eflags: --503-0C
                .word   op00_010_111-10$       ; RLA  eflags: SZ503P0C
                .word   op00_011_111-10$       ; RRA  eflags: SZ503P0C
                .word   op00_100_111-10$       ; DAA  eflags: SZ5*3P-*
                .word   op00_101_111-10$       ; CPL  eflags: --*1*-1-
                .word   op00_110_111-10$       ; SCF  eflags: --*0*-01
                .word   op00_111_111-10$       ; CCF  eflags: --***-0*
            brw   unknown_op                   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; rot into carry
rrcx:
;          +-------------------------+
;          |    +-+-+-+-+-+-+-+-+    |
;          +--> | | | | | | | | | -> + -> C
;               +-+-+-+-+-+-+-+-+
;
            ; input r2 byte pointer
            ; return byte in r4
            ; I/O reg_F
            ; RLC/RL/RRC/RR r       SZ503P0C
            ; TOCHECK: reg_F gets the correct cleared bits?
            bicb2   #^x13, reg_F            ; H, N, C
            movzbl  (r2), r4                ; get byte
            clrl    r3
            bicb3   #^x0FE, r4, r3          ; bit 0 -> r3
            bisb2   r3, reg_F               ; set C in z80flags

            ashl    #8, r3, r3              ; mk mask for bit8
            bisl2   r3, r4                  ; add bit before shift
            ashl    #-1, r4, r4             ; shift right
            movzbl  r4, r4
            bicb2   #z80Flagm_HN, reg_F     ; 0x12 clear H, N flags
            rsb

                
rlcx:
;          +-->---------->-------->--+
;     +-+  |    +-+-+-+-+-+-+-+-+    |
;     |C|<-+<-- |7|6|5|4|3|2|1|0| <--+
;     +-+       +-+-+-+-+-+-+-+-+
;
; b7 -> C, b0
;
            ; input r2 byte pointer
            ; return byte in r4
            ; I/O reg_F
            bicb2   #^x13, reg_F            ; H, N, C
            movzbl  (r2), r4                ; get byte
            clrl    r3
            bicb3   #^x07F, r4, r3          ; bit 7 -> r3
            ashl    #-7, r3, r3             ; shift right get the bit in C position of flags
            bisb2   r3, reg_F               ; set C in z80flags
            ashl    #1, r4, r4              ; shift left
            bisl2   r3, r4                  ; add bit before shift
            movzbl  r4, r4
            bicb2   #z80Flagm_HN, reg_F     ; 0x12 clear H, N flags
            rsb

; Rot through Carry
rrx:
;           +------------------------------+
;           |    +-+-+-+-+-+-+-+-+   +-+   |
;           +--> |7|6|5|4|3|2|1|0| ->|C| ->+
;                +-+-+-+-+-+-+-+-+   +-+
;
            ; input r2 byte pointer
            ; return byte in r4
            ; I/O reg_F
            ; eflags: SZ503P0C

         ; save the current z80 Carry in r5
            clrl    r5
	    bicb3   #^x0FE, reg_F, r5       ; get the current Z80 C flag in r5

            bicb2   #z80Flagm_HN, reg_F     ; 0x12 clear H, N flags

            movzbl  (r2), r4                ; get byte

            clrl    r3
            bicb3   #^x0FE, r4, r3          ; bit 0 -> r3 Save the bit to carry

            ashl    #8, r5, r5              ; mk mask for bit 8 of carry flag 1xx
            bisl2   r5, r4                  ; add bit before shift  1xx

            ashl    #-1, r4, r4             ; shift right being the C into bit 7
            bisb2   r3, reg_F               ; set C in z80flags

            movzbl  r4, r4
            rsb


rlx: ; rla 
;           +--->---------->-------->----+
;           |  +-+   +-+-+-+-+-+-+-+-+   |
;           +<-|C|<- |7|6|5|4|3|2|1|0| <-+
;              +-+   +-+-+-+-+-+-+-+-+
;
            ; input r2 byte pointer
            ; return byte in r4
            ; I/O reg_F
            ; eflags: SZ503P0C

         ; save the current z80 Carry in r5
            clrl    r5
            bicb3   #^xFE, reg_F, r5        ; get the orig C from flag

            bicb2   #z80Flagm_HN, reg_F     ; 0x12 clear H, N flags

            movzbl  (r2), r4                ; get byte


         ; bit 7 to Z80 Carry flag
	    clrl    r3
            bicb3   #^x7F, r4, r3           ; bit 7 -> r3 save the bit to carry
	    ashl    #-7, r3, r3             ; move bit7 to bit 0 ie C
                                            ; r3 will be the new z80_C
	    bisb2   r3, reg_F               ; set the Z80 C to bit 7


            ashl    #1, r4, r4              ; shift left
	    bicb2   #^x01, r4               ; clear lower bit
            bisb2   r5, r4                  ; OR the orig Z80 C flag to the lower bit

            movzbl  r4, r4
            rsb

op00_000_111:                               ; RLCA
            movab   reg_A, r2
            bsbw    rlcx
            movb    r4, reg_A
            brw     fetch
            
op00_001_111:                               ; RRCA
;          +-------------------------+
;          |    +-+-+-+-+-+-+-+-+    |
;          +--> | | | | | | | | | -> + -> C
;               +-+-+-+-+-+-+-+-+
;
            ; input r2 byte pointer
            movab   reg_A, r2
            bsbw    rrcx
            movb    r4, reg_A
            brw     fetch
            
op00_010_111:                               ; RLA
            movab   reg_A, r2
            bsbb    rlx
            movb    r4, reg_A
            brw     fetch
            
op00_011_111:                               ; RRA
            movab   reg_A, r2
            bsbw    rrx
            movb    r4, reg_A
            brw     fetch
            
            
op00_100_111:                               ; DAA
            movzbl  reg_A, r2
            extzv   #0, #4, r2, r4          ; get lower nibble
            extzv   #4, #4, r2, r3          ; get upper nibble
            bbs     #z80Flagb_SUBN, reg_F, DAA_SUB
;DAA_ADD:
            cmpb    r4, #^x09
            blss    10$                     ; branch if >9
            bbc     #z80Flagb_H, reg_F, 20$ ; branch if no add required

    10$:    bicb2   #z80Flagm_H, reg_F      ; clear H flag

            addb2   #^x06, r4               ; add to lower nibble

	    cmpzv   #4, #4, r4, #0          ; Check for half carry look for non-zero in
                                            ; upper nibble after add of 06
            beql    20$                     ; branch if no half carry

            bisb2   #z80Flagm_H, reg_F      ; set half carry
            incb    r3                      ; add the carry to upper nibble (nibble)

    20$:    cmpb    r3, #^x09
            blss    30$                     ; branch if add no req (<=9)
            bbc     #z80Flagb_C, reg_F, 40$ ; branch if no add required

    30$:    bicb2   #z80Flagm_C, reg_F      ; clear C flag

            addb2   #^x06, r3               ; add to Upper nibble look of Carry

	    cmpzv   #4, #4, r3, #0          ; Check for carry look for non-zero in
                                            ; upper nibble after add of 06
            beql    40$                     ; branch if no half carry

            bisb2   #z80Flagm_C, reg_F      ; set Carry
    40$:    
            bicb2   #^xf0, r4		    ; lower nibble 
            bicb2   #^xf0, r3               ; upper nibble
            ashl    #4, r3, r3
            bisb3   r4, r3, reg_A

daa_end:

            bisb2  parity_mask[r2], reg_F   ; or the bit P flag

	    tstb    reg_A
            bneq    34$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    34$:    brw     fetch
    
DAA_SUB:    ; r2 = byte r3 = Hnibble r4 = Lnibble

	    bicb3   #^x0f, r2, r3           ; get the upper nibble in r3 with out shift right4

            cmpb    r3, #^x90		    ; start with Upper Nibble for sub
            blss    10$                     ; branch if add required  r3 > 90
            bbc     #z80Flagb_C, reg_F, 20$ ; branch if NO add required

    10$:    bicb2   #z80Flagm_C, reg_F      ; clear C flag

            subb2   #^x60, r3               ; sub 6 from upper nibble

	    cmpzv   #0, #4, r3, #0          ; Check for half carry look for non-zero in Lnibble
            beql    20$                     ; branch if no half borrow
            bisb2   #z80Flagm_H, reg_F      ; set half borrow
            decb    r4                      ; dec the half borrow from Lower nibble

    20$:    cmpb    r4, #^x09
            blss    40$                     ; branch if add no req (<=9 TODO: check??)
            bbc     #z80Flagb_H, reg_F, 40$ ; branch if no sub 06 required

            subb2   #^x06, r4               ; sub from Lower Nibble
            bisb2   #z80Flagm_C, reg_F      ; set borrow
    40$:    
            bicb2   #^xf0, r4		    ; lower nibble 
            bicb2   #^x0f, r3               ; upper nibble
            bisb3   r4, r3, reg_A

            brb     daa_end
            
op00_101_111:                               ; CPL complement A
            ; --*1*-1-
            ; eflags: ---1--1-
            mcomb   reg_A, reg_A
            bicb2   #^x13, reg_F            ; H, N, C
            bisb2   #z80Flagm_HN, reg_F     ; set H & N flags
            brw     fetch
            
op00_110_111:                               ; SCF set carry flag
            ; SCF eflags: ---0--01 
            bicb2   #^x13, reg_F            ; H, N, C
            bisb2   #z80Flagm_C,  reg_F     ; set C
            brw     fetch
            
op00_111_111:                               ; CCF complement carry flag
            ; CPL eflags: ---?--0C    F5, F3 from A register
            blbc    reg_F, op00_110_111     ; set carry flag
            bicb2   #^x13, reg_F            ; H, N, C
            bicb2   #z80Flagm_C,  reg_F     ; clear C
            brw     fetch
            
;-----------------------------------------------------------------------
halt:       movb    s^#1, runflag           ; set the halt flag
            brw     halt_message            ; must continue via brw fetch

op01:                                       ; LD r, r'
            cmpb    r0, #^x76               ; is it HALT?
            beql    halt

; 01{dst r2}{src r4} 

  ld_src:   bsbw    XXxxxrrr
            movl    r2, r4

  ld_dst:   bsbw    XXrrrxxx
            movb    (r4), (r2)

            brw     fetch
;-------------------------------------------------------------------
op10:
src2:       bsbw    XXxxxrrr
            movzbl  (r2), r3
            
alu_r3toA:  extzv    #3, #3, r0, r2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb    r2, #0, #7           ;
    10$:        .word    op10_000_rrr-10$ ; ADD A, r eflags: SZ5H3VNC
                .word    op10_001_rrr-10$ ; ADC A, r eflags: SZ5H3VNC
                .word    op10_010_rrr-10$ ; SUB A, r eflags: SZ5H3VNC
                .word    op10_011_rrr-10$ ; SBC A, r eflags: SZ5H3VNC
                .word    op10_100_rrr-10$ ; AND A, r
                .word    op10_101_rrr-10$ ; XOR A, r
                .word    op10_110_rrr-10$ ; OR  A, r
                .word    op10_111_rrr-10$ ; CP  A, r
            brw   unknown_op              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               
op10_000_rrr:                               ; ADD A, r
            ; eflags: SZ5H3VNC
            clrb   reg_F                    ; clear S,Z,5,H,3,V,N,C
            bsbw   addr3toA                 ; add r3 to A
            brw    fetch
            
op10_001_rrr:                               ; ADC A, r
            ; eflags: SZ5H3VNC
            bicb2  #^xD6, reg_F             ; clear S,Z,5,H,3,V,N,
            bisb3  #^x28, r0, r4            ; get bits 5,3
            bisb2  r4, reg_F                ; copy the 5,3 bits to flags

            blbc   reg_F, 10$               ; branch if NC
            movl   r3, r7                   ; save r3
            movzbl #1, r3
            bsbw   addr3toA
            movl   r7, r3
    10$:    bsbw   addr3toA
            brw    fetch
            
op10_010_rrr:                               ; SUB A, r
            ; eflags: SZ5H3VNC
            clrb   reg_F                    ; clear S,Z,5,H,3,V,N,C
            bisb2  #z80Flagm_SUBN, reg_F    ; set N_flags ???
            ;bicb2  #^xD5, reg_F             ; clear S,Z,H,V,C flags
            ;bisb3  #^x28, r0, r4            ; get bits 5,3 == 0,0
            ;bisb2  r4, reg_F                ; copy the 5,3 bits to flags

            bsbw   subr3toA
            brw    fetch
            
op10_011_rrr:                               ; SBC A, r
            ; eflags: SZ5H3VNC
            bisb2  #z80Flagm_SUBN, reg_F    ; set N flags
            bicb2  #^xD4, reg_F             ; clear S,Z,5,H,-,,V,, flags
            blbc   reg_F, 10$               ; branch NC
            movl   r3, r7                   ; save r3
            movzbl #1, r3
            bsbw   subr3toA
            movl   r7, r3
    10$:    bsb    subr3toA
            brw    fetch
            
addr3toA:                                   ; subroutine to add r3 to reg_A
            ; eflags: SZ5H3VNC
            extzv  #0, #4, r3, r4           ; get lower nibble in r3
            extzv  #0, #4, reg_A, r6        ; get lower nibble of A in r6
            addb2  r4, r6                   ; add lower nibbles
	    cmpzv  #4, #4, r6, #0           ; look for a Half carry
            beql   no_H1                    ; branch if no Half Carry
            bisb2  #z80Flagm_H, reg_F       ; set H_flag
    no_H1:
            addb2  r3, reg_A                ; do add set vax flags
            movpsl r5
	    bicb2   #z80Flagm_S, reg_F      ; assume +ve result
            blbc   r5, 31$                  ; branch noCarry
            bisb2  #z80Flagm_C, reg_F       ; set C flag
    31$:    bbc    #vaxFlag_V, r5, 32$      ; branch nooVerflow
            bisb2  #z80Flagm_PV, reg_F      ; set V flag
    32$:    bbc    #vaxFlag_Z, r5, 33$      ; branch VaxZero
            bisb2  #z80Flagm_Z, reg_F       ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve 
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve 

    34$:    rsb
    
subr3toA:                                   ; subroutine to sub r3 from reg_A
            ; eflags: SZ5H3VNC
	    movzbl reg_A, r2
            extzv  #0, #4, r3, r4           ; get lower nibble in r3
            extzv  #0, #4, r2, r6           ; get lower nibble of A in r6
            subb2  r4, r6                   ; sub lower nibbles
	    cmpzv  #4, #4, r6, #0           ; look for a Half carry
            beql   no_H2                    ; branch if no Half Carry
            bisb2  #z80Flagm_H, reg_F       ; set H_flag
    no_H2:
            subb2  r3, reg_A                ; do sub set vax flags
            movpsl r5
	    bicb2   #z80Flagm_S, reg_F      ; assume +ve result
            blbc   r5, 31$
            bisb2  #z80Flagm_C, reg_F       ; set C flag
    31$:    bbc    #vaxFlag_V, r5, 32$
            bisb2  #z80Flagm_PV, reg_F      ; set V flag
    32$:    bbc    #vaxFlag_Z, r5, 33$
            bisb2  #z80Flagm_Z, reg_F       ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    rsb
    
op10_100_rrr:                               ; AND A, r
            ; eflags: SZ513P00
            clrb   reg_F
            bisb2  #^x30, reg_F             ; set 5,H
            mcomb  r3, r3
            bicb2  r3, reg_A

logsetflags:
            movpsl r5
	    bicb2   #z80Flagm_S, reg_F      ; assume +ve result

            bbc    #vaxFlag_Z, r5, 33$      ; test vax_psw:2=Z
            bisb2  #z80Flagm_Z, reg_F       ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:
            movzbl reg_A, r4
            bisb2  parity_mask[r4], reg_F   ; or the bit P flag

    60$:    brw    fetch
    
op10_101_rrr:                               ; XOR A, r   
            ; eflags: SZ503P00/SZ100P00
            clrb   reg_F
            bicb2  #^xD7, reg_F             ; clear S, Z, H, P, N, C
            xorb2  r3, reg_A
            brb    logsetflags

op10_110_rrr:                               ; OR A, r
            ; eflags: SZ503P00
            bicb2  #^xD7, reg_F             ; clear S,Z,H,P,N,C
            bisb2  r3, reg_A                ; or reg_A with r3
            brb    logsetflags
            
op10_111_rrr:                               ; CP A, r
            ; eflags: SZ*H*VNC
            bicb2  #^xD5, reg_F             ; clear S,Z,H,P,C
            bisb2  #z80Flagm_SUBN, reg_F    ; set N
            movb   reg_A, r7                ; temp save reg_A
            bsbw   subr3toA                 ; sub neg(r3) to reg_A
            movb   r7, reg_A                ; restore reg_A
            brw    fetch
;---------------------------------------------------------------
op11:
            ;extzv    #0, #3, r0, r2        ; already done just after fetched:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb    r2, #0, #7             ;
    10$:        .word    op11_ccc_000-10$   ; RET ccc
                .word    op11_xxx_001-10$   ; POP rr, RET, EXX, PCHL, SPHL
                .word    op11_ccc_010-10$   ; JP ccc, pq
                .word    op11_xxx_011-10$   ; CB group, OUT, IN, EX (SP), HL, EX DE,HL,DI, EI
                .word    op11_ccc_100-10$   ; CALL ccc, pq
                .word    op11_xxx_101-10$   ; PUSH rr, CALL pq, DD IX, ED group, FD IY
                .word    op11_xxx_110-10$   ; reg_A, n instructions
                .word    op11_xxx_111-10$   ; RST
             brw      halt                  ; unreachable
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    FLGTBL: .byte    6,0,2,7	            ; Z,C,PV,S

op11_ccc_000:                               ; RET ccc
            extzv   #4, #2, r0, r2          ; cc bits 4,2 in r2 Z, C, PV, S (0,1,2,3)
            movzbl  FLGTBL[r2], r3          ; get bit pos of flag (6,0,2,7)
	    extzv   r3, #1, reg_F, r3       ; get flag bit in r3
            extzv   #3, #1, r0, r1          ; C3 from ccc
	    xorl2   r3, r1
            xorl2   #1, r1		    ; invert the bit

      5$:   blbc    r1, end_RET             ; 0 = don't jump

	    ; jump
op_RETSUB:
	    decl    CALLDEPTH
	    bsbw    newline
op_RET:
            movzwl  reg_SP, r2
            movb    (r2)[r11], NEW_PC
            incw    r2
            movb    (r2)[r11], NEW_PC+1
            incw    r2
            movw    r2, reg_SP
            movzwl  NEW_PC, r10
 end_RET:   brw     fetch
 
;;;;;;;;;;;;;
op11_xxx_001:                               ; POP rr, RET, EXX, PCHL, SPHL
;;;;;;;;;;;;;
            extzv   #4, #2, r0, r2          ; get register#
            bbs     #3, r0, 50$             ; branch if RET,EXX,PCHL,SPHL
	    ; POP rr
            movl    ptr_AF,     r3          ; get dest address in r3
            cmpb    r2, #3
            beql    20$                     ; branch if not AF reg
     10$:   movl    ptr_BC[r2], r3          ; dest BC,DE,IDX address in r3
     20$:   movzwl  reg_SP,     r2
            movb    (r2)[r11], (r3)+        ; autoinc ok here we pointing to nxt reg
                                            ; not memory with wrap-around
            incw    r2
            movb    (r2)[r11], (r3)

            incw    r2
            movw    r2, reg_SP
            brw     fetch
             
     50$:   ; r2 = op, 00=RET/ 01=EXX/ 10=JP (HL)/ 11=LD SP, HL
            tstb    r2
            beql    op_RETSUB_L
            cmpb    r2, #2
            blss    op_EXX
            beql    op_PCHL
            ;bgtr   op_SPHL
             
op_SPHL:    movw    @ptr_IDX, reg_SP        ; HL->SP
            brw     fetch

op_RETSUB_L: brw op_RETSUB
            
op_PCHL:    movzwl  @ptr_IDX, r10           ; HL->PC
            brw     fetch
            
op_EXX:     movl    reg_BC, r2              ; BC,DE ->r2
            movzwl  reg_HL, r3              ; HL->r3
            
            movl    reg_BC2, reg_BC         ; BC2,DE2-> BC,DE
            movw    reg_HL2, reg_HL
            
            movl    r2, reg_BC2             ; BC,DE -> BC2, DE2
            movw    r3, reg_HL2             ; HL->HL2
            brw     fetch
            
op11_ccc_010:                               ; JP ccc, pq
            movb    (r10)[r11], NEW_PC      ; fetch the jump address into NEW_PC
            incw    r10
            movb    (r10)[r11], NEW_PC+1
            incw    r10

            extzv   #4, #2, r0, r2          ; cc bits 4,2 in r2 Z, C, PV, S (0,1,2,3)
            movzbl  FLGTBL[r2], r3          ; get bit pos of flag (6,0,2,7)
            extzv   r3, #1, reg_F, r3       ; get flag bit in r3
            extzv   #3, #1, r0, r1          ; C3 from ccc
            xorl2   r3, r1
            xorl2   #1, r1                  ; invert the bit

      5$:   blbc    r1, 10$

            movzwl  NEW_PC, r10             ; do JMP
     10$:   brw     fetch
            
;;;;;;;;;;;;;
op11_xxx_011:
;;;;;;;;;;;;;
            extzv   #3, #3, r0, r2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r2, #0, #7         ;
    10$:        .word op11_000_011-10$ ; JP pq
                .word op11_001_011-10$ ; CB group
                .word op11_010_011-10$ ; OUT (n), A
                .word op11_011_011-10$ ; IN A, (n)
                .word op11_100_011-10$ ; EX (SP), HL
                .word op11_101_011-10$ ; EX DE, HL
                .word op11_110_011-10$ ; DI
                .word op11_111_011-10$ ; EI
            brw   unknown_op           ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                
op11_000_011:                               ; JP pq
            movb    (r10)[r11], NEW_PC
            incw    r10
            movb    (r10)[r11], NEW_PC+1
            incw    r10
            movzwl  NEW_PC, r10
            brw     fetch
            
;op11_001_011 see below this is the CB group

op11_010_011:                               ; OUT (n), A
            movzbl  (r10)[r11], r2          ; fetch n
            incw    r10
            pushl   r2
            movzbl  reg_A, -(sp)
            calls   #2, z80_out
            brw     fetch
            
op11_011_011:                               ; IN A, (n)
            movzbl  (r10)[r11], r2          ; fetch n
            incw    r10
            pushl   r2
            calls   #1, z80_in
            movb    r0, reg_A
            ;clrb    reg_A                   ; return 0
            brw     fetch

op11_100_011:                               ; EX (SP), HL
            movzwl  reg_SP, r1              ; get stack ptr
            movl    ptr_IDX, r2             ; get address of index reg
            movb    (r2), r3
            movb    (r1)[r11], (r2)
            movb    r3, (r1)[r11]
            incw    r2
            incw    r1
            movb    (r2), r3
            movb    (r1)[r11], (r2)
            movb    r3, (r1)[r11]
            brw     fetch
            
op11_101_011:                               ; EX DE, HL
            movzwl  reg_DE, r2
            movw    @ptr_IDX, reg_DE
            movw    r2, @ptr_IDX
            brw     fetch
        
op11_110_011:                               ; DI
            movb     #^xff, intflg
            brw      fetch

op11_111_011:                               ; EI
            clrb     intflg
            brw      fetch
            

;;;;;;;;;;;;;;;;;;
;  CB Group      ;
;;;;;;;;;;;;;;;;;;

op11_001_011: ; CB group
            movzbl   (r10)[r11], r0         ; fetch opcode
            incw     r10

            bsbw     XXxxxrrr		    ; results in r2

            extzv    #6, #2, r0, r5
            beql     opCB00

            extzv    #3, #3, r0, r3         ; the bit number

            movl     #1, r4
            ashl     r3, r4, r4             ; create bit mask in r4

            caseb    r5, #0, #3
               10$:  .word opCB00-10$ ; 00 branch already done after extzv
                     .word opCB01-10$ ; 01 BIT
                     .word opCB10-10$ ; 10 RES
                     .word opCB11-10$ ; 11_SET
            brw   unknown_op          ; never reached

opCB01:     ; BIT  eflags: *Z513*0-  PV as Z, S set only if n=7 and b7 of r set
            bicb2    #z80Flagm_ZN, reg_F    ; 0x42 clear Z, N
            bisb2    #z80Flagm_H , reg_F    ; set H
            bitb     r4, (r2)               ; set bit
            beql     10$
            bisb2    #vaxFlag_Z, reg_F      ; set Z flag
    10$:    brw      fetch
    
            
opCB10:     ; RES 
            bicb2    r4, (r2)
            brw      fetch
            
opCB11:     ; SET
	    bisb2    r4, (r2)
            brw      fetch

opCB00:
            movzbl   (r2), r4
            bicb2    #^xD6, reg_F           ; clear S,Z,H,P,N
            extzv    #3, #3, r0, r3         ; get opcode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb    r3, #0, #7             ;
    10$:        .word opCB_00_000_rrr-10$   ; RLC r eflags: SZ503P0C
                .word opCB_00_001_rrr-10$   ; RRC r eflags: SZ503P0C
                .word opCB_00_010_rrr-10$   ; RL  r eflags: SZ503P0C
                .word opCB_00_011_rrr-10$   ; RR  r eflags: SZ503P0C
                .word opCB_00_100_rrr-10$   ; SLA r eflags: SZ503P0C
                .word opCB_00_101_rrr-10$   ; SRA r eflags: SZ503P0C
                .word opCB_00_110_xxx-10$   ; Not DEFINED opCB_00_110 
                .word opCB_00_111_rrr-10$   ; SRL r
            brw   unknown_op                ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                

;;;;;;;;;;;;;;;;
opCB_00_000_rrr:                            ; RLC
;;;;;;;;;;;;;;;;
            bsbw    rlcx
            brw     CBsetflags
    
;;;;;;;;;;;;;;;;
opCB_00_001_rrr:                            ; RRC
;;;;;;;;;;;;;;;;
            bsbw    rrcx
            brw     CBsetflags
            
;;;;;;;;;;;;;;;;
opCB_00_010_rrr:                            ; RL
;;;;;;;;;;;;;;;;
            bsbw    rlx
            brb     CBsetflags

;;;;;;;;;;;;;;;;
opCB_00_011_rrr:                            ; RR
;;;;;;;;;;;;;;;;
            bsbw    rrx
            brb     CBsetflags
            
;;;;;;;;;;;;;;;;
opCB_00_100_rrr:                            ; SLA
;;;;;;;;;;;;;;;;
;               +-+-+-+-+-+-+-+-+
;          C <- | | | | | | | | | <- 0
;               +-+-+-+-+-+-+-+-+
;
            bicb2    #z80Flagm_C, reg_F     ; clear C
            ashl     #1, r4, r4
            bbc      #8, r4, 10$
            bicb2    #z80Flagm_C, reg_F     ; bit7 ->C
    10$:    brb      CBsetflags
    
;;;;;;;;;;;;;;;;
opCB_00_101_rrr:                            ; SRA
;;;;;;;;;;;;;;;;
;               +-+-+-+-+-+-+-+-+
;            +->| | | | | | | | | -> C
;            |  +-+-+-+-+-+-+-+-+
;            |___|
;
            bicb3   #^xfe, r4, r3           ; get LBit0
            bisb2   r3       , reg_F        ; set the carry flag
            bicb3   #^x7F, r4, r5           ; get the Hbit7
            movzbl  r4, r4                  ; clear upper part of lw
            ashl    #-1, r4, r4
            bisb2   r5, r4                  ; mask bit 7 back
            brb     CBsetflags              ; fall through to code no need to branch

;;;;;;;;;;;;;;;;
opCB_00_110_xxx:
;;;;;;;;;;;;;;;;
	    brw     unknown_op              ; Not DEFINED opCB_00_110 

;;;;;;;;;;;;;;;;
opCB_00_111_rrr:                            ; SRL
;;;;;;;;;;;;;;;;
;               +-+-+-+-+-+-+-+-+
;          0 -> | | | | | | | | | -> C
;               +-+-+-+-+-+-+-+-+
;
            bicb3   #^xfe, r4, r3           ; get LBit0
            bisb2   r3, reg_F               ; set the carry flag
            ashl    #1, r4, r4
            ;brb    CBsetflags               ; fall through to code no need to branch
            
CBsetflags: ; set S, Z, P
            ; eflags: SZ503P0C
            movb    r4, (r2)
            beql    10$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag
    10$:    bbc     #z80Flagb_S, r4, 20$
            bisb2   #z80Flagm_S, reg_F      ; set S flag
    20$:    movzbl  r4, r4
            bisb2   parity_mask[r4], reg_F  ; set P flag
    60$:    brw     fetch
    

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
op11_ccc_100:                               ; CALL ccc, pq
;;;;;;;;;;;;;
            movb    (r10)[r11], NEW_PC
            incw    r10
            movb    (r10)[r11], NEW_PC+1
            incw    r10

            extzv   #4, #2, r0, r2          ; cc bits 4,2 in r2 Z, C, PV, S (0,1,2,3)
            movzbl  FLGTBL[r2], r3          ; get bit pos of flag (6,0,2,7)
            extzv   r3, #1, reg_F, r3       ; get flag bit in r3
            extzv   #3, #1, r0, r1          ; C3 from ccc
            xorl2   r3, r1
            xorl2   #1, r1                  ; invert the bit


      5$:   blbs    r1, docall
            brw     fetch

docall:     
            movw    r10, TEMP               ; zPC to TEMP
            movzwl  NEW_PC, r10             ; doJMP

	    incl    CALLDEPTH	            ; for debug trace inc the level
   5$:
            movzwl  reg_SP, r2              ; get the Z80 Stackpointer  word
            decw    r2                      ; sp-1
            movb    TEMP+1, (r2)[r11]       ; push Ret addr LOW
            decw    r2                      ; sp-1
            movb    TEMP, (r2)[r11]         ; push Ret addr HIGH
            movw    r2, reg_SP              ; save r2 back as stackpointer
            brw     fetch
            
            
;;;;;;;;;;;;;
op11_xxx_101: ; PUSH rr, CALL pq,    DD IX, ED group, FD IY
;;;;;;;;;;;;;
	    extzv   #4, #2, r0, r2          ; get register#
            bbs     #3, r0, opCallEDEDFD    ; branch if opEDEDFD

            ; PUSH rr
            movl    ptr_AF, r3              ; get address of AF in r3
            cmpb    r2, #3                  ; is it AF
            beql    20$                     ; branch if not AF
            movl    ptr_BC[r2], r3          ; address BC,DE,HL/IDX in r3
    20$:    movzwl  reg_SP, r2
            decw    r2
            movb    b^1(r3), (r2)[r11]      ; High register to stack
            decw    r2
            movb    (r3), (r2)[r11]         ; Low register to stack
            movw    r2, reg_SP
            brw     fetch

    opCallEDEDFD:    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r2, #0, #4        ;
     51$:         .word  op_CALL-51$  ;  00 = CD CALL
                  .word  op_DD-51$    ;  01 = DD use IX
                  .word  op_ED-51$    ;  10 = ED ED group
                  .word  op_FD-51$    ;  11 = FD use IY
            brw   unknown_op          ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

op_CALL:    movb    (r10)[r11], NEW_PC      ; fetch the address to call into NEW_PC
            incw    r10
            movb    (r10)[r11], NEW_PC+1
            incw    r10
            brw     docall

; 2016feb not so simple next opcode can be different
;DDCBddCr  SET 0,(IX+dd),r  r={B,C,D,E,H,L,A}
;So for example with the last instruction, the value of (IX+10h) with bit 0 set is also
; stored in register A.
;The DDCB BIT instructions do not store any value
; they merely test a bit. That bis why the undocumented DDCB BIT instructions are no
; different from the official ones: 3.6
;
op_FD:                                      ; use IY
            movaw   reg_IY, ptr_IDX
            brw     fetch2
op_DD:                                      ; use IX
            movaw   reg_IX, ptr_IDX
            brw     fetch2

            
op_ED:                                      ; ED group
            movzbl  (r10)[r11], r0          ; fetch op code
            incw    r10

            extzv   #0, #6, r0, r3
            extzv   #6, #2, r0, r2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r2, #0, #4          ;
    10$:          .word opED_00-10$     ; BIOS
                  .word opED_01-10$     ;0 IN    r, (C) & tstport(C)
                                        ;1 OUT    r, (C),
					;2 SBC    ADC 16bit HL, rr
                                        ;3 LD    (pq), rr LD rr, (pq)
                                        ;4 NEG reg_A
                                        ;5 RETN RETI
                                        ;6 IM0 IM1 IM2
                                        ;7 LD IorR , A LD a, IorR RRD A RLDA
                  .word opED_10-10$     ; block ops
                  .word opED_11-10$     ; BIOS ops
            brw   unknown_op            ; unreachable
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            
opED_00:
            brw   bios00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
opED_11:
            brw   bios11

opED_01:
            extzv   #0, #3, r0, r3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #0, #7                ;
    10$:        .word    opED_01_xxx_000-10$  ;0 IN    r, (C) & tstport(C)
                .word    opED_01_xxx_001-10$  ;1 OUT    r, (C)
                .word    opED_01_xxx_010-10$  ;2 SBC    ADC 16bit HL, rr
                .word    opED_01_xxx_011-10$  ;3 LD    (pq), rr LD rr, (pq)
                .word    opED_01_xxx_100-10$  ;4 NEG reg_A eflags: SZ5H3V1C  A=0-A
                .word    opED_01_xxx_101-10$  ;5 RETN RETI
                .word    opED_01_xxx_110-10$  ;6 IM0 IM1 IM2
                .word    opED_01_xxx_111-10$  ;7 LD IorR , A LD a, IorR RRD A RLDA
            brw   unknown_op                  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               
opED_01_xxx_000:                            ; IN r, (C)
            extzv   #4, #2, r0, r3          ; get register
            cmpb    r3, #3                  ; is it tst only
            bneq    5$
            bbs     #3, r0, 10$             ; branch if reg_A
            movab   TEMP, r2                ; store result to be lost
            brb     20$
    5$:     movl    ptr_BC[r3], r2
            bbs     #3, r0, 20$
            brb     15$
    10$:    movl    ptr_AF, r2
    15$:    incl    r2
    20$:
            clrb    (r2)                    ; return 0
            bicb2   #^xD6, reg_F            ; clear S,Z,H,P,N
            brw     fetch
            
opED_01_xxx_001:                            ; OUT (C), r
            extzv   #4, #2, r0, r3          ; get register
            cmpb    r3, #3                  ; is it tst only
            bneq    5$
            bbs     #3, r0, 10$             ; branch if reg_A
            movab   TEMP, r2                ; store result to be lost
            brb     20$
    5$:     movl    ptr_BC[r3], r2
            bbs     #3, r0, 20$
            brb     15$
    10$:    movl    ptr_AF, r2
    15$:    incl    r2                      ; select lower reg of pair
    20$:
            brw     fetch
            
opED_01_xxx_010:                            ; SBC HL, rr  ADC HL, rr
            ;NOTE: Half carry/borrow bit 11. I have not supported setting H flag for this event. TODO: 2013 WTFnot
            ; H is set if borrow from bit 12 otherwise, it is reset.
            ; ADC/SBC s     eflags: SZ***VNC  F5,H,F3 from higher bytes addition

            extzv   #4, #2, r0,  r2
            movzwl  @ptr_BC[r2], r2         ; src z80 word 
            movl    ptr_IDX,     r3         ; dst local word address
	    blbc    reg_F, 10$
	    incw    r2
      10$:
            bbs     #3, r0, op_ADCHL

op_SBCHL:
            bicb2   #^xD7, reg_F            ; clear S,Z,H,V,C
	    bisb2   #z80Flagm_SUBN, reg_F   ; set N
            subw2   r2, (r3)
            brb     opED_Csetflags
op_ADCHL:
            bicb2   #^xD7, reg_F            ; clear S,Z,V,N,C
            addw2   r2, (r3)

opED_Csetflags:
            movpsl  r5
	    bicb2   #z80Flagm_S, reg_F      ; assume +ve result

            blbc    r5, 10$
            bisb2   #z80Flagm_C, reg_F      ; set C flag

    10$:    bbc     #vaxFlag_V, r5, 20$
            bisb2   #z80Flagm_PV, reg_F     ; set V flag

    20$:    bbs     #vaxFlag_Z, r5, 33$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    brw     fetch
    
    
opED_01_xxx_011:                            ; LD (pq), rr  LD rr, (pq)
            movb    (r10)[r11], TEMP        ; fetch pq
            incw    r10
            movb    (r10)[r11], TEMP+1
            incw    r10

            extzv   #4, #2, r0, r2          ; get reg #
            movl    ptr_BC[r2], r2          ; get address of reg in r2
            movzwl  TEMP,  r1               ; get the value of the Z80 address
            bbs     #3, r0, opLDrrpq
opLDpqrr:
            movb    (r2)+, (r1)[r11]        ; reg to memory
            incw    r1
            movb    (r2), (r1)[r11]
            brw     fetch
opLDrrpq:
            movb    (r1)[r11], (r2)+        ; memory to reg
            incw    r1
            movb    (r1)[r11], (r2)
            brw     fetch
            
opED_01_xxx_100:                            ; NEG A
            ; eflags: SZ5H3V1C  A=0-A
            cmpb    r0, #^x44
            bneq    10$
            bicb2   #^xD5, reg_F            ; clear S,Z,H,V,C
            bicb2   #z80Flagm_S,    reg_F
            bisb2   #z80Flagm_SUBN, reg_F   ; SUB

            extzv   #0, #4, reg_A, r2       ; get low nibble
            mnegb   r2, r2
	    cmpzv   #4, #4, r2, #1          ; test for Half carry in upper nibble
            beql    10$                     ; branch if no H
            bisb2   #z80Flagm_H, reg_F      ; set H flag
    10$:    mnegb   reg_A, reg_A
            movpsl  r5
            blbc    r5, 20$
            bisb2   #z80Flagm_C, reg_F      ; set C flag
    20$:    bbc     #vaxFlag_V, r5, 30$
            bisb2   #z80Flagm_PV, reg_F     ; set V flag
    30$:    bbc     #vaxFlag_Z, r5, 33$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    brw     fetch
    
opED_01_xxx_101:
            cmpb    r0, #^x45
            beql    10$                     ; RETN
            cmpb    r0, #^x4D
            beql    10$                     ; RETI
            brw     unknown_op              ; NOP all else
    10$:    brw     op_RET

opED_01_xxx_110:                            ; IM0, IM1, IM2
            extzv   #3, #3, r0, r3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #0, #7              ;
    10$:         .word opED_01_000_110-10$  ; 46 IM 0
                 .word opED_01_001_110-10$  ; 4E unknown_op
                 .word opED_01_010_110-10$  ; 56 IM 1
                 .word opED_01_011_110-10$  ; 5E IM 2
                 .word opED_01_100_110-10$  ; 66 unknown_op
                 .word opED_01_101_110-10$  ; 6E unknown_op
                 .word opED_01_110_110-10$  ; 76 unknown_op
                 .word opED_01_111_110-10$  ; 7E unknown_op
            brw      unknown_op             ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
opED_01_001_110: ; 4E  LOADDFLG nnnn  
            movb    (r10)[r11], TEMP
            incw    r10
            movb    (r10)[r11], TEMP+1
	    incw    r10
	    movzwl  TEMP, DFLG
	    tstl    DFLG
	    bneq    10$
    10$:
            brw	    fetch

opED_01_100_110:                            ; 66 LOADDEPTH nnnn
            movb    (r10)[r11], TEMP
            incw    r10
            movb    (r10)[r11], TEMP+1
            incw    r10
            movzwl  TEMP, CALLDEPTH
            brw     fetch

opED_01_101_110: ; 6E LOADTRACE nnnn
            movb    (r10)[r11], TEMP
            incw    r10
            movb    (r10)[r11], TEMP+1
            incw    r10
            movzwl  TEMP, TRACEDEPTH
            brw     fetch

opED_01_110_110: ; 76 dumpreg
            bsbw    dump_z80_reg
            brw     fetch

opED_01_111_110: ; 77 BRK
            incl    brkflag                 ; set low bit
            brw     fetch


opED_01_000_110: ;46 IM 0
            brw      fetch
opED_01_010_110: ;56 IM 1
            brw      fetch
opED_01_011_110: ;5E IM 2
            brw      fetch
            
opED_01_xxx_111:
            extzv    #3, #3, r0, r2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb    r2, #0, #5             ;
    10$:        .word opED_01_000_111-10$   ; LD I,A eflags: SZ503*0-  PV as IFF2
                .word opED_01_001_111-10$   ; LD R,A eflags: SZ503*0-  PV as IFF2
                .word opED_01_010_111-10$   ; LD A,I eflags: SZ503*0-  PV as IFF2
                .word opED_01_011_111-10$   ; LD A,R eflags: SZ503*0-  PV as IFF2
                .word opED_01_100_111-10$   ; RRD A eflags: SZ503P0-
                .word opED_01_101_111-10$   ; RLD A
            brw      unknown_op             ; 110 & 111
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

opED_01_000_111:                            ; LD I,A
            ; eflags: SZ503*0-  PV as IFF2
            movb     reg_A, reg_I
            brw      fetch
            
opED_01_001_111:                            ; LD R, A
            ; eflags: SZ503*0-  PV as IFF2
            movb     reg_A, reg_R
            brw      fetch
        
opED_01_010_111:                            ; LD A, I
            ; eflags: SZ503*0-  PV as IFF2
            movb     reg_I, reg_A
    ISET:   bicb2    #^xD6, reg_F           ; clear S,Z,H,V,N
            tstb     reg_A
            beql     10$
            bisb2    #z80Flagm_Z, reg_F     ; set Z flag
    10$:    bbc      #6, reg_A, 20$
            bisb2    #z80Flagm_S, reg_F     ; set S flag
    20$:    brw      fetch
    
opED_01_011_111:                            ; LD A, R
            ; eflags: SZ503*0-  PV as IFF2
            movb     reg_R, reg_A
            brb      ISET
            
opED_01_100_111:                            ; RRD A
            ; eflags: SZ503P0-  Flags set on result in A
            bicb2    #^xD6, reg_F           ; clear S,Z,H,P,N
            movzwl   reg_HL, r1
            addl3    r1, r11, r8            ; make vax relative
            extzv    #0, #4, reg_A, r2      ; Lnibble A
            extzv    #0, #4, (r8) , r3      ; Lnibble (HL)
            extzv    #4, #4, (r8) , r4      ; Hnibble (HL)
            clrb     (r8)
            bicb2    #^x0F, reg_A           ; clear Lnibble A
;1
            bisb2    r3, reg_A              ; Lnibble (HL) -> Lnibble A
            bisb2    r4, (r8)               ; Hbibble (HL) -> Lnibble (HL)
            ashl     #4, r2, r2             ; Lnibble  A  shifted left 4 bits
            bisb2    r2, (r8)               ; Lnibble  A -> Hnibble (HL)
;4
            tstb    reg_A
            movpsl  r5
            bicb2   #z80Flagm_S, reg_F      ; clear S +ve

            bbc     #vaxFlag_Z, r5, 33$
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    movzbl  reg_A, r4               ; P flag
            bisb2   parity_mask[r4], reg_F  ; or the bit P flag
            brw     fetch
    
opED_01_101_111:                            ; RLD A
            bicb2   #^xD6, reg_F            ; clear S,Z,H,P,N
            movzwl  reg_HL, r1
            addl3   r1, r11, r8             ; make vax relative
            extzv   #0, #4, reg_A, r2       ; Lnibble A
            extzv   #0, #4,  (r8), r3       ; Lnibble (HL)
            extzv   #4, #4,  (r8), r4       ; Hnibble (HL)
            clrb    (r8)
            bicb2   #^x0F, reg_A            ; clear Lnibble A
;1
            bisb    r4, reg_A               ; Hnibble (HL) -> Lnibble A
            ashl    #4, r3, r3              ; Lnibble (HL) left shift 4 bits
            bisb3   r2, r3, (r8)            ; Lnibble A -> Lnibble (HL)
                                            ; && Lnibble (HL) -> Hnibble (HL)
;4
            tstb    reg_A

            movpsl  r5
            bicb2   #z80Flagm_S, reg_F      ; clear S +ve

            bbc     #vaxFlag_Z, r5 , 33$
            bisb2   #z80Flagm_Z, reg_F

    33$:    bbc     #vaxFlag_N, r5, 34$     ; Branch if VAX +ve
            bisb2   #z80Flagm_S, reg_F      ; clear S flag 1=-ve,  z80 0=+ve

    34$:    movzbl  reg_A, r4               ; P flag
            bisb2   parity_mask[r4], reg_F  ; or the bit P flag
            brw     fetch                   ; ?2013 odd
        
;;;;;;;;
opED_10:                                    ; block ops
            bisb2   #^x16, reg_F            ; clear H,V,N
            movzwl  @ptr_IDX, r1            ; src
            movzwl  reg_DE,   r4            ; dst
            extzv   #3, #3, r0, r3          ; middle 3bits __XXX___
            extzv   #0, #3, r0, r2          ; lower  3bits _____XXX

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r2, #0, #7              ;
      10$:      .word opED_10_xxx_000-10$   ; LDI,LDD,LDIR,LDDR
                .word opED_10_xxx_001-10$   ; CPI,CPIR,CPD,CPDR
                .word opED_10_xxx_010-10$   ; INI,INIR, IND,INDR
                .word opED_10_xxx_011-10$   ; OUTI,OUTIR,OUTD,OUTDR
                .word opED_10_xxx_100-10$   ; unknown_op
                .word opED_10_xxx_101-10$   ; unknown_op
                .word opED_10_xxx_110-10$   ; unknown_op
                .word opED_10_xxx_111-10$   ; unknown_op
            brw     unknown_op              ; never reached NOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

opED_10_xxx_000:                            ; op_LD
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #4, #7              ;
    10$:        .word opED_10_100_000-10$   ; LDI  Blk Inc
                .word opED_10_101_000-10$   ; LDD  Blk Dec
                .word opED_10_110_000-10$   ; LDIR Blk Inc Repeat
                .word opED_10_111_000-10$   ; LDDR Blk Dec Repeat
            brw     unknown_op              ; 000,001,010,011 unknown
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 2013 - 24years on this looks like rubish not indexing  the movb
opED_10_100_000:                            ; LDI
            ; eflags:  --*0**0-  PV set if BC not 0
            bicb2   #^x3E, reg_F            ; clear 5,H,3,V
            movb    (r1)[r11], (r4)[r11]

            incw    @ptr_IDX
            incw    reg_DE
            decw    reg_BC
            bneq    15$

            bisb2   #z80Flagm_Z!z80Flagm_PV, reg_F ; set V flag
    15$:    brw     fetch
    
opED_10_110_000:                            ; LDIR
            ; eflags:  --*0**0-  PV set if BC not 0
; Repeats LDI (LD (DE),(HL), then increments DE, HL, and decrements BC) until BC=0.
;  Note that if BC=0 before this instruction is called, it will loop around until BC=0 again.
; repeat {(DE) <- (HL), DE++ , HL++, BC--} while (BC != 0)

            bicb2   #^x3E, reg_F            ; clear 5,H,3,V
            movzwl  reg_BC, r5

    10$:    movb    (r1)[r11], (r4)[r11]    ; (HL) -> (DE)
            incw    r1                      ; HL++
            incw    r4                      ; DE++
	    decw    r5                      ; BC--
            bneq    10$
	    
    15$:
            movw    r5,  reg_BC
	    movw    r4,  reg_DE
            movw    r1,  @ptr_IDX

            bisb2   #z80Flagm_Z!z80Flagm_PV, reg_F ; set V flag
            clrw    reg_BC
            brw     fetch
            
opED_10_101_000:                            ; LDD
            ; eflags:  --*0**0-  PV set if BC not 0
            bicb2   #^x3E, reg_F            ; clear 5,H,3,V
            movb    (r1)[r11], (r4)[r11]

            decw    @ptr_IDX
            decw    reg_DE
            decw    reg_BC
            bneq    15$

            bisb2   #z80Flagm_Z!z80Flagm_PV, reg_F  ; set V flag
    15$:    brw     fetch

opED_10_111_000:                            ; LDDR
            ; eflags:  --*0**0-  PV set if BC not 0
            movzwl  reg_BC, r5

10$:        movb    (r1)[r11], (r4)[r11]
            decw    r1                      ; HL--
            decw    r4                      ; DE--
            decw    r5                      ; BC--
            bneq    10$

15$:        movw    r5,  reg_BC
	    movw    r4,  reg_DE
            movw    r1,  @ptr_IDX

            bisb2   #z80Flagm_Z!z80Flagm_PV, reg_F ; set V flag
            clrw    reg_BC
            brw     fetch

opED_10_xxx_001:                            ; CPI,CPD,CPIR,CPDR
            ; eflags:  SZ*H**1-  PV set if BC not 0
            bicb2   #^xD4, reg_F            ; clear S,Z,H,V
            bisb2   #^x02, reg_F            ; set N flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #4, #7              ;
    10$:        .word  opED_10_100_001-10$  ; CPI
                .word  opED_10_101_001-10$  ; CPD
                .word  opED_10_110_001-10$  ; CPIR
                .word  opED_10_111_001-10$  ; CPDR
            brw    unknown_op               ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            
opED_10_100_001:                            ; CPI
            ; eflags:  SZ*H**1-  PV set if BC not 0
            movzwl  @ptr_IDX, r1
            movzbl  (r1)[r11], r3
            movb    reg_A, r7               ; temp save reg_A
            bsbw    subr3toA                ; add neg(r3) to reg_A
            movb    r7, reg_A               ; restore reg_A
            incw    @ptr_IDX

            decw    reg_BC
            bneq    10$

            bisb2   #^x04, reg_F            ; set V flag
    10$:    brw     fetch
    
opED_10_110_001:                            ; CPIR
            ; eflags:  SZ*H**1-  PV set if BC not 0
    10$:    movzwl  @ptr_IDX, r1
            movzbl  (r1)[r11], r3
            movb    reg_A, r7               ; temo save reg_A
            bsbw    subr3toA                ; sub r3 from reg_A
            movb    r7, reg_A               ; restore reg_A
            incw    @ptr_IDX
            incw    r1
            decw    reg_BC
            bneq    10$

            bisb2   #z80Flagm_PV, reg_F     ; set V flag
            brw     fetch
            
opED_10_101_001:                            ; CPD
            ; eflags:  SZ*H**1-  PV set if BC not 0
            movzwl  @ptr_IDX, r1
            movzbl  (r1)[r11], r3
            movb    reg_A, r7               ; temp save reg_A
            bsbw    subr3toA                ; sub r3 from reg_A
            movb    r7, reg_A               ; restore reg_A
            decw    @ptr_IDX
            decw    reg_BC
            bneq    10$

            bisb2   #z80Flagm_PV, reg_F     ; set V flag
    10$:    brw     fetch
    
opED_10_111_001:                            ; CPDR
            ; eflags:  SZ*H**1-  PV set if BC not 0
    10$:    movzwl  @ptr_IDX, r1
            movzbl  (r1)[r11], r3
            movb    reg_A, r7               ; temp save reg_A
            bsbw    subr3toA                ; sub r3 from reg_A
            movb    r7, reg_A               ; restore reg_A
            decw    @ptr_IDX
            decw    r1
            decw    reg_BC
            bneq    10$

            bisb2   #z80Flagm_PV, reg_F     ; set V flag
            brw     fetch
            
opED_10_xxx_010:                            ; INI,INIR, IND,INDR
            ; eflags: SZ5?3???  Flags affected as in DEC B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #4, #7              ;
    10$:        .word opED_10_100_010-10$   ; A2 INI
                .word opED_10_101_010-10$   ; AA IND
                .word opED_10_110_010-10$   ; B2 INIR
                .word opED_01_111_010-10$   ; BA INDR
            brw     unknown_op              ; 000,001,010,011 unknown
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

opED_10_100_010:                            ;A2 INI
            brw       fetch
opED_10_101_010:                            ;AA IND
            brw       fetch
opED_10_110_010:                            ;B2 INIR
            brw       fetch
opED_01_111_010:                            ;BA INDR
            brw       fetch

opED_10_xxx_011:                            ; OUTI,OUTIR,OUTD,OUTDR
            ; eflags: SZ5?3???  Flags affected as in DEC B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb   r3, #4, #7              ;
    10$:        .word opED_10_100_011-10$   ; OUTI
                .word opED_10_101_011-10$   ; OUTD
                .word opED_10_110_011-10$   ; OUTIR
                .word opED_01_111_011-10$   ; OUTDR
            brw     unknown_op              ; 000,001,010,011 unknown
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

opED_10_100_011:                            ; OUTI
            brw       fetch
opED_10_101_011:                            ; OUTD
            brw       fetch
opED_10_110_011:                            ; OUTIR
            brw       fetch
opED_01_111_011:                            ; OUTDR 
            brw       fetch

opED_10_xxx_100:
opED_10_xxx_101:
opED_10_xxx_110:
opED_10_xxx_111:
            brw     unknown_op
            
;-------------
op11_xxx_110:                               ; alu ops a, n
            movzbl  (r10)[r11], r3          ; fetch n
            incw    r10
            brw     alu_r3toA
            
op11_xxx_111:                               ; RST
            movzwl  reg_SP, r1
            movw    r10, NEW_PC
            decw    r1
            movb    NEW_PC, (r1)[r11]
            decw    r1
            movb    NEW_PC+1, (r1)[r11]
            movw    r1, reg_SP
            extzv   #3, #3, r0, r2
            ashl    #3, r2, r10
            brw     fetch

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
bios11:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
           caseb       r3, #0,#63           ;
10$:           .word bios_0_BOOT-10$        ; 00 BOOT (function 0)
               .word bios_1_WBOOT-10$       ; 01 WBOOT (function 1)
               .word bios_2_CONST-10$       ; 02 CONST (function 2)
               .word bios_3_CONIN-10$       ; 03 CONIN (function 3)
               .word bios_4_CONOUT-10$      ; 04 CONOUT (function 4)
               .word bios_5_LIST-10$        ; 05 LIST (function 5)
               .word bios_6_PUNCHAUXOUT-10$ ; 06 PUNCH / AUXOUT (function 6)
               .word bios_7_READER-10$      ; 07 READER (function 7)
               .word bios_8_HOME-10$        ; 08 HOME (function 8)
               .word bios_9_SELDSK-10$      ; 09 SELDSK (function 9)
               .word bios_10_SETTRK-10$     ; 0A SETTRK (function 10)
               .word bios_11_SETSEC-10$     ; 0B SETSEC (function 11)
               .word bios_12_SETDMA-10$     ; 0C SETDMA (function 12)
               .word bios_13_READ-10$       ; 0D READ (function 13)
               .word bios_14_WRITE-10$      ; 0E WRITE (function 14)
               .word bios_15_LISTST-10$     ; 0F LISTST (function 15)
               .word bios_16_SECTRAN-10$    ; 10 SECTRAN (function 16)
               .word bios_17_CONOST-10$     ; 11 CONOST (function 17)
               .word bios_18_AUXIST-10$     ; 12 AUXIST (function 18)
               .word bios_19_AUXOST-10$     ; 13 AUXOST (function 19)
               .word bios_20_DEVTBL-10$     ; 14 DEVTBL (function 20)
               .word bios_21_DEVINI-10$     ; 15 DEVINI (function 21)
               .word bios_22_DRVTBL-10$     ; 16 DRVTBL (function 22)
               .word bios_23_MULTIO-10$     ; 17 MULTIO (function 23)
               .word bios_24_FLUSH-10$      ; 18 FLUSH (function 24)
               .word bios_25_MOVE-10$       ; 19 MOVE (function 25)
               .word bios_26_TIME-10$       ; 1A TIME (function 26)
               .word bios_27_SELMEM-10$     ; 1B SELMEM (function 27)
               .word bios_28_SETBNK-10$     ; 1C SETBNK (function 28)
               .word bios_29_XMOVE-10$      ; 1D XMOVE (function 29)
               .word bios_30_USERF-10$      ; 1E USERF (function 30)
               .word bios_31_RESERV1-10$    ; 1F RESERV1 (functions 31)
               .word bios_32_RESERV2-10$    ; 20 RESERV2 (functions 32)
       
               .word BDOS_9_C_WRITESTR-10$  ; 21 BDOS_9_C_WRITESTR  RESERV3 (functions 33)
               .word bios_34_RESERV4-10$    ; 22 RESERV4 (functions 34)
               .word bios_35_RESERV5-10$    ; 23 RESERV5 (functions 35)
               .word bios_36_RESERV6-10$    ; 24 RESERV6 (functions 36)
               .word bios_37_RESERV7-10$    ; 25 RESERV7 (functions 37)
               .word bios_38_RESERV8-10$    ; 26 RESERV8 (functions 38)
               .word bios_39_RESERV9-10$    ; 27 RESERV9 (functions 39)
               .word bios_40_RESERV10-10$   ; 28 RESERV10 (functions 40)
               .word bios_41_RESERV11-10$   ; 29 RESERV11 (functions 41)
               .word bios_42_RESERV12-10$   ; 2A RESERV12 (functions 42)
               .word bios_43_RESERV13-10$   ; 2B RESERV13 (functions 43)
               .word bios_44_RESERV14-10$   ; 2C RESERV14 (functions 44)
               .word bios_45_RESERV15-10$   ; 2D RESERV15 (functions 45)
               .word bios_46_RESERV16-10$   ; 2E RESERV16 (functions 46)
               .word bios_47_RESERV17-10$   ; 2F RESERV17 (functions 47)
               .word bios_48_RESERV18-10$   ; 30 RESERV18 (functions 48)
               .word bios_49_RESERV19-10$   ; 31 RESERV19 (functions 49)
               .word bios_50_RESERV20-10$   ; 32 RESERV20 (functions 50)
               .word bios_51_RESERV21-10$   ; 33 RESERV21 (functions 51)
               .word bios_52_RESERV22-10$   ; 34 RESERV22 (functions 52)
               .word bios_53_RESERV23-10$   ; 35 RESERV23 (functions 53)
               .word bios_54_RESERV24-10$   ; 36 RESERV24 (functions 54)
               .word bios_55_RESERV25-10$   ; 37 RESERV25 (functions 55)
               .word bios_56_RESERV26-10$   ; 38 RESERV26 (functions 56)
               .word bios_57_RESERV27-10$   ; 39 RESERV27 (functions 57)
               .word bios_58_RESERV28-10$   ; 3A RESERV28 (functions 58)
               .word bios_59_RESERV29-10$   ; 3B RESERV29 (functions 59)
               .word bios_60_RESERV30-10$   ; 3C RESERV30 (functions 60)
               .word bios_61_RESERV31-10$   ; 3D RESERV31 (functions 61)
               .word bios_62_RESERV32-10$   ; 3E RESERV32 (functions 62)
               .word bios_63_RESERV33-10$   ; 3F RESERV33 (functions 63)
            brw    unknown_op               ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
bios_0_BOOT:
;
;BOOT (function 0)
;
; This function is completely implementation-dependent and
; should never be called from user code.
;
            brw     bios_ret
;;;;;;;;;;;;;
bios_1_WBOOT:
;
;BOOT (function 1)
; Reloads the command processor and (on some systems) the BDOS as well.
; How it does this is implementation-dependent; it may use the reserved
; tracks of a floppy disc or extra memory.
;
            brw     bios_ret

;;;;;;;;;;;;;
bios_2_CONST:
;
;CONST (function 2)
;
; Returns its status in A; 0 if no character is ready, 0FFh if one is.
;
;
            tstb    tt_buf                  ; do we have a char?
            bneq    10$                     ; branch if char in buf

            ; buf emty try a read?
            $QIO_S  efn=#1                            ,-
                    func=#IO$_READVBLK!IO$M_NOECHO    ,-
                    chan=TT_CHAN                      ,-
                    iosb=TT_IOSB                      ,-
                    p1=tt_buf                         ,-
                    p2=#1                             ; request getch
            bsbw    error
            
    5$:     tstb    tt_buf                  ; did we get a char?
            bneq    10$                     ; branch Yes
            clrb    reg_A                   ; tell them no char
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag
            brw     bios_ret

    10$:    movb    #^xFF, reg_A            ; tell them we got a char
            bicb2   #z80Flagm_Z, reg_F      ; clear Z flag
            brw     bios_ret
            

;;;;;;;;;;;;;
bios_3_CONIN:
;
;CONIN (function 3)
;
;Wait until the keyboard is ready to provide a character, and return it in A.
;
            bicb2   #z80Flagm_PV, reg_F     ; clear P flag aka V
            tstb    tt_buf                  ; do we have a character from tst?
            bneq    10$                     ; branch if char already in tt_buf

            ; otherwise get one now
            $QIOW_S  efn=#1                           ,-
                    func=#IO$_READVBLK!IO$M_NOECHO    ,-
                    chan=TT_CHAN                      ,-
                    iosb=TT_IOSB                      ,-
                    p1=tt_buf                         ,-
                    p2=#1                   ; request getch
            bsbw    error
        
   10$:     movb    tt_buf, reg_A
            clrb    tt_buf
            movb    #^xFF, l^save_key(r11)
	    bicb2   #z80Flagm_Z,  reg_F
            bisb2   #z80Flagm_PV, reg_F     ; set P flag aka V
            brw     bios_ret

;;;;;;;;;;;;;;
bios_4_CONOUT:
;
;CONOUT (function 4)
;
; Write the character in C to the screen.
;
           $QIOW_S efn=#2                ,-
                   func=#IO$_WRITEVBLK   ,-
                   chan=TT_CHAN          ,-
                   iosb=TT_IOSB          ,-
                   p1=reg_C              ,-
                   p2=#1
            bsbw   error

            brw    bios_ret

;;;;;;;;;;;;
bios_5_LIST:
;
;LIST (function 5)
;
;Write the character in C to the printer. If the printer isn't ready,
; wait until it is.
;
            brw     bios_ret

;;;;;;;;;;;;;;;;;;;
bios_6_PUNCHAUXOUT:
;
;PUNCH / AUXOUT (function 6)
;
;Write the character in C to the "paper tape punch" - or whatever the
; current auxiliary device is. If the device isn't ready, wait until it is.
;
;This function is called PUNCH in CP/M 2.x, AUXOUT in CP/M 3.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_7_READER:
;
;READER (function 7)
;
;Read a character from the "paper tape reader" - or whatever the current auxiliary device is. If the device isn't ready, wait until it is. The character will be returned in A. If this device isn't implemented, return character 26 (^Z).
;
;This function is called READER in CP/M 2.x, AUXIN in CP/M 3.
;
            brw     bios_ret

;;;;;;;;;;;;
bios_8_HOME:
;
;
;HOME (function 8)
;
;Move the current drive to track 0.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_9_SELDSK:
;
;SELDSK (function 9)
;
;Select the disc drive in register C (0=A:, 1=B: ...). Called with E=0 or 0FFFFh.
;
;If bit 0 of E is 0, then the disc is logged in as if new; if the format has to be determined from the boot sector, for example, this will be done.
;
;If bit 0 if E is 1, then the disc has been logged in before. The disc is not accessed; the DPH address (or zero) is returned immediately.
;
;SELDSK returns the address of a Disc Parameter Header in HL. The exact format of a DPH varies between CP/M versions; note that under CP/M 3, the DPH is in memory bank 0 and probably not visible to programs. If the disc could not be selected it returns HL=0.
;
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_10_SETTRK:
;
;SETTRK (function 10)
;
;Set the track in BC - 0 based.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_11_SETSEC:
;
;SETSEC (function 11)
;
;Set the sector in BC. Under CP/M 1 and 2 a sector is 128 bytes.
; Under CP/M 3 the sector size is given in the Disk Parameter Block.
;
;There has been discussion in comp.os.cpm about whether the parameter
; to this function is a byte or a word. The conclusion (based on
; examining the BDOS source) was that it is a word.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_12_SETDMA:
;
;SETDMA (function 12)
;
;The next disc operation will read its data from (or write its
; data to) the address given in BC.
;
            brw     bios_ret

;;;;;;;;;;;;;
bios_13_READ:
;
;READ (function 13)
;
;Read the currently set track and sector at the current DMA address.
; Returns A=0 for OK, 1 for unrecoverable error, 0FFh if media changed.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_14_WRITE:
;
;WRITE (function 14)
;
;Write the currently set track and sector. C contains a deblocking code:
;
;C=0 - Write can be deferred
;C=1 - Write must be immediate
;C=2 - Write can be deferred, no pre-read is necessary.
;Returns A=0 for OK, 1 for unrecoverable error, 2 if disc is readonly, 0FFh if media changed.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_15_LISTST:
;
;LISTST (function 15)
;
;Return status of current printer device.
;
;Returns A=0 (not ready) or A=0FFh (ready).
;
            brw     bios_ret

;;;;;;;;;;;;;;;;
bios_16_SECTRAN:
;
;SECTRAN (function 16)
;
;Translate sector numbers to take account of skewing.
;
;On entry, BC=logical sector number (zero based) and DE=address of translation table. On exit, HL contains physical sector number. On a system with hardware skewing, this would normally ignore DE and return either BC or BC+1.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_17_CONOST:
;
;CONOST (function 17)
;
;Return status of current screen output device.
;Returns A=0 (not ready) or A=0FFh (ready).
;
            movb    #^xff  , reg_A
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_18_AUXIST:
;
;AUXIST (function 18)
;
;Return status of current auxiliary input device.
;
;Returns A=0 (not ready) or A=0FFh (ready).
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_19_AUXOST:
;
;AUXOST (function 19)
;
;Return status of current auxiliary output device.
;
;Returns A=0 (not ready) or A=0FFh (ready).

            brw     bios_ret

;;;;;;;;;;;;;;;
bios_20_DEVTBL:
;
;DEVTBL (function 20)
;
;Return in HL the address of the devices table, or 0 if the devices table isn't implemented.
;
;The devices table will be visible to programs without the need for bank switching, ie. it will be in common memory.
;
;The device table contains one entry for each character device. Each entry is formed:
;
;    DEFB    'NAME  '    ;Name, 6 bytes. If the first byte is zero,
;                ;this is the end of the table.
;    DEFB    mode        ;Bitmapped value:
;                ;Bit 0 set => can input from this device
;                ;Bit 1 set => can output to this device
;                ;Bit 2 set => can change the baud rate
;                ;Bit 3 set => supports XON/XOFF
;                ;Bit 4 set => is using XON/XOFF
;                ;Bits 5,6,7 set to 0.
;                ; Amstrad extension: If bit 7 is set, output
;                ;to the device does not time out. 
;    DEFB    baudrate    ;Coded speed, 1-15 or 0 if speed can't be
;                ;changed.
;                ;Rates are 50,75,110,134.5,150,300,600,1200,
;                ;         1800,2400,3600,4800,7200,9600,19200.
;The maximum number of devices allowed in CP/M Plus is unclear. The documentation variously says there can be 12 or 13, while the DEVICE.COM source code suggests 15.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_21_DEVINI:
;
;DEVINI (function 21)
;
;Reinitialise character device number C - called when the device's settings (baud rate, mode etc.) are changed.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_22_DRVTBL:
;
;DRVTBL (function 22)
;
;Return in HL the address of the drive table, or 0 (or 0FFFFh, or 0FFFEh) if the drive table isn't implemented. The drive table contains 16 pointers to the Disc Parameter Headers of the 16 disc drives A-P; if a pointer is 0 it means that the corresponding drive does not exist.
;
;The drive table is usually (but not always) in common memory (ie accessible by user programs).
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_23_MULTIO:
;
;MULTIO (function 23)
;
;Notify the BIOS that the BDOS is intending to transfer a number of consecutive disc sectors with READ or WRITE. Entered with C = number of calls that will be made; up to 16k of data will be transferred.
;
;The idea is that after the MULTIO call, the BIOS can choose to transfer all the data in the first READ/WRITE operation, and then not to do anything on the subsequent (n-1) operations.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_24_FLUSH:
;
;FLUSH (function 24)
;
;Write any pending data to disc.
;
;Returns A=0 if successful, 1 for physical disc error, 2 for drive R/O.
;
;This function is only useful when the BIOS is doing the deblocking - ie, the physical sector size is not the size that the BIOS reports to the BDOS.
;
            brw     bios_ret

;;;;;;;;;;;;;
bios_25_MOVE:
;
;MOVE (function 25)
;
;Move BC bytes of memory, from the address in DE to the address in HL (the other way round from the Z80's LDIR instruction). Should return HL and DE pointing to the first addresses not copied. If XMOVE is used before this function, data are moved between two memory banks.
;
            brw     bios_ret

;;;;;;;;;;;;;
bios_26_TIME:
;
;TIME (function 26)
;
;Get the current date and time into the SCB (at BOOT-0Ch). HL and DE must be preserved. If C=0FFh, then set the time from the SCB instead.
;
;The format of the 5-byte buffer is:
;
;    DW    day    ;Day 1 is 1 Jan 1978
;    DB    hour    ;packed BCD
;    DB    minute    ;packed BCD
;    DB    second    ;packed BCD

            brw     bios_ret

;;;;;;;;;;;;;;;
bios_27_SELMEM:
;
;SELMEM (function 27)

;
;Set the current bank to the number in A. Bank 1 is the bank in which user programs run (the TPA); Bank 0 and any other banks are used by CP/M for disc buffers or as a RAMdisc.
;
;According to the DRI documentation, this function must preserve all registers except A.
;
            brw     bios_ret

;;;;;;;;;;;;;;;
bios_28_SETBNK:
;
;SETBNK (function 28)
;
;Set the bank to be used for the next read/write sector operation. The bank number is passed in A. Note that the BDOS will call SETBNK after calling SETDMA; some BIOSes insist on this order, so it's safest if your programs do the same.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_29_XMOVE:
;
;XMOVE (function 29)
;
;After XMOVE, the next call to MOVE will move data between different memory banks. Call XMOVE with C=source bank and B=destination bank. According to the CP/M Plus System Guide, the BDOS will only ever use this function to move 128 or fewer bytes in one go; some BIOSes may not support bigger moves between banks.
;
            brw     bios_ret

;;;;;;;;;;;;;;
bios_30_USERF:
;
;USERF (function 30)
;
;This function is reserved for the author of the BIOS to add any extra features. On Amstrad computers, for example, this call accesses the extended BIOS functions.
;
            brw     bios_ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESERV1 and RESERV2 (functions 31, 32)
;
;These calls are reserved and contain JMP 0 instructions.
; for the moment make them unknown_op!
;
;;;;;;;;;;;;;;;;
bios_31_RESERV1:
            brw     bios_ret

;;;;;;;;;;;;;;;;
bios_32_RESERV2:
            brw     bios_ret

;;;;;;;;;;;;;;;;;;
BDOS_9_C_WRITESTR:      ;   bios_33_RESERV3:
; Entered with BDOS function C=9, DE=address of string.
; ignore C

            movl    r3, save_reg
            movzwl  reg_DE, r3
10$:
            movb    (r3)+[r11], tt_buf
            cmpb    tt_buf, #^A/$/          ; cmp to '$'
            beql    20$
            $QIOW_S efn=#2              ,-
                    func=#IO$_WRITEVBLK ,-
                    chan=TT_CHAN        ,-
                    iosb=TT_IOSB        ,-
                    p1=tt_buf           ,-
                    p2=#1
            bsbw    error
            brb     10$

20$:
            movl    save_reg, r3
            brw     bios_ret

bios_34_RESERV4:
        brw     unknown_op                  ; NOP
bios_35_RESERV5:
        brw     unknown_op                  ; NOP
bios_36_RESERV6:
        brw     unknown_op                  ; NOP
bios_37_RESERV7:
        brw     unknown_op                  ; NOP
bios_38_RESERV8:
        brw     unknown_op                  ; NOP
bios_39_RESERV9:
        brw     unknown_op                  ; NOP
bios_40_RESERV10:
        brw     unknown_op                  ; NOP
bios_41_RESERV11:
        brw     unknown_op                  ; NOP
bios_42_RESERV12:
        brw     unknown_op                  ; NOP
bios_43_RESERV13:
        brw     unknown_op                  ; NOP
bios_44_RESERV14:
        brw     unknown_op                  ; NOP
bios_45_RESERV15:
        brw     unknown_op                  ; NOP
bios_46_RESERV16:
        brw     unknown_op                  ; NOP
bios_47_RESERV17:
        brw     unknown_op                  ; NOP
bios_48_RESERV18:
        brw     unknown_op                  ; NOP
bios_49_RESERV19:
        brw     unknown_op                  ; NOP
bios_50_RESERV20:
        brw     unknown_op                  ; NOP
bios_51_RESERV21:
        brw     unknown_op                  ; NOP
bios_52_RESERV22:
        brw     unknown_op                  ; NOP
bios_53_RESERV23:
        brw     unknown_op                  ; NOP
bios_54_RESERV24:
        brw     unknown_op                  ; NOP
bios_55_RESERV25:
        brw     unknown_op                  ; NOP
bios_56_RESERV26:
        brw     unknown_op                  ; NOP
bios_57_RESERV27:
        brw     unknown_op                  ; NOP
bios_58_RESERV28:
        brw     unknown_op                  ; NOP
bios_59_RESERV29:
        brw     unknown_op                  ; NOP
bios_60_RESERV30:
        brw     unknown_op                  ; NOP
bios_61_RESERV31:
        brw     unknown_op                  ; NOP
bios_62_RESERV32:
        brw     unknown_op                  ; NOP
bios_63_RESERV33:
        brw     unknown_op                  ; NOP

bios_ret:
        brw        fetch

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
bios00:
            extzv    #0, #6, r0, r3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            caseb    r3, #0, #9             ;
    10$:        .word    const-10$          ; C0
                .word    conin-10$          ; C1
                .word    conout-10$         ; C2
                .word    diskio-10$         ; C3
                .word    diskio-10$         ; C4
                .word    read_rdr-10$       ; C5
                .word    write_pun-10$      ; C6
                .word    write_lpt-10$      ; C7
                .word    flash-10$          ; C8
                .word    OFFLOAD-10$        ; C9 DISKIO BC BYTES
                .word    BLOCKWRITE-10$     ; CA DISKIO BC BYTES
            brw     unknown_op              ; unreachable
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                
diskio:
            movzwl  reg_HL, r1
            addl3   r1, r11, r8
            $RAB_STORE  rab=drive_A$RAB  ,-
                        RBF=(r8)         ,-
                        UBF=(r8)            ; set buff address
            movzbl  reg_D, r2               ; Trk no
            movzbl  reg_E, r4               ; sec no
            mull2   #REC128_TRK, r2         ; trks * sec/trk
            addl3   r2, r4, rec_no
            $FIND   drive_A$RAB
            bsbw    error
            cmpb    r3, #2
            beql    readtdse
            ;blss    writetdse
writetdse:
            $UPDATE drive_A$RAB
            bsbw    error
            bisb2   #z80Flagm_Z, reg_F      ; ret Z true
            clrb    reg_A
            brw     op_RET
            
readtdse:
            $GET    drive_A$RAB
            bsbw    error
            bisb2   #z80Flagm_Z, reg_F      ; ret Z true
            clrb    reg_A
            brw     op_RET
            
read_rdr:
            tstw    rdr$FAB+FAB$W_IFI       ; is the file open
            bneq    10$                     ; branch if yes
            $OPEN   rdr$FAB
            bsbw    error
            $CONNECT rdr$RAB
            bsbw    error
            clrw    rdrptr
    10$:    cmpw    rdrptr, rdr$RAB+RAB$W_RSZ
            blss    15$                     ; branch if not end of buffer
            $GET    rdr$RAB
            bsbw    error
            clrw    rdrptr
    15$:
            movzwl  rdrptr, r0
            bicb2   #z80Flagm_Z, reg_F      ; set NZ flag always a char
            movb    rdr$rec[r0], reg_A
            incw    rdrptr
            cmpb    reg_A, #^x1a            ; is it control-Z ie EOF ?
            bneq    20$
            $CLOSE  rdr$FAB
            bsbw    error
    20$:    brw     op_RET
    
write_pun:
            tstw    pun$FAB+FAB$W_IFI       ; is the file open
            bneq    10$
            $CREATE pun$FAB
            bsbw    error
            $CONNECT pun$RAB
            bsbw    error
            clrw    punptr
    10$:
            movzwl  punptr, r0
            bicb2   #z80Flagm_Z, reg_F      ; set NZ flag always a char
            movb    reg_A, pun$rec[r0]
            incw    punptr
            cmpb    reg_A, #^x0a            ; is it control-Z ie EOF?
            bneq    20$
            $CLOSE  pun$FAB
            bsbw    error
    20$:    brw     op_RET

write_lpt:
            tstw    lpt$FAB+FAB$W_IFI       ; is the file open?
            bneq    10$
            $CREATE lpt$FAB
            bsbw    error
            $CONNECT lpt$RAB
            bsbw    error
            clrw    lptptr
    10$:
            movzwl  lptptr, r0
            bicb2   #z80Flagm_Z, reg_F      ; set NZ flag always a char
            movb    reg_A, lpt$rec[r0]
            incw    lptptr
            cmpb    reg_A, #^x0a            ; is it LF
            bneq    15$
            $PUT    lpt$RAB
            bsbw    error
            clrw    lptptr
    15$:    cmpb    reg_A, #^x1a            ; is it control-Z ie EOF?
            bneq    20$
            $CLOSE  lpt$FAB
            bsbw    error
    20$:    brw     op_RET
    
    
flash:
; put top of screen in reverse video message at (HL) last char high bit set
            movb    #^x1b, reg_C
            bsbw    outchar
            movb    #^a/[/, reg_C
            bsbb    outchar            
            movb    #^a/0/, reg_C
            bsbb    outchar
            movb    #^a/;/, reg_C
            bsbb    outchar
            movb    #^a/5/, reg_C
            bsbb    outchar
            movb    #^a/;/, reg_C
            bsbb    outchar
            movb    #^a/7/, reg_C
            bsbb    outchar
            movb    #^a/m/, reg_C
            bsbb    outchar

            movzwl  reg_HL, r5
    10$:    movzbl  (r5)[r11], r4
            incw    r5
            bicb3   #^x80, r4, reg_C
            bsbb    outchar
            bbc     #7, r4, 10$
            
            movb    #^x1b, reg_C
            bsbb    outchar
            movb    #^a/[/, reg_C
            bsbb    outchar            
            movb    #^a/0/, reg_C
            bsbb    outchar
            movb    #^a/m/, reg_C
            bsbb    outchar
            
            brw     op_RET
            
outchar:
            $QIOW_S efn=#2              ,-
                    func=#IO$_WRITEVBLK ,-
                    chan=TT_CHAN        ,-
                    iosb=TT_IOSB        ,-
                    p1=reg_C            ,-
                    p2=#1
            bsbw    error
            rsb
            
BLOCKWRITE:
            movzbl   reg_D,       r2        ; Trk no
            movzbl   reg_E,       r3        ; sec no
            mull2    #REC128_TRK, r2        ; trks * sec/trk
            addl3    r2,    r3,   rec_no
            movzwl   reg_BC,      r1        ; get num bytes to write
            divl3    #128,  r1,   r2        ; r2 = num full sectors
            mull3    #128,  r2,   r3
            subl3    r3,    r1,   r4        ; remainder in r4
            movzwl   reg_HL,      r5
            
    10$:    addl3    r5, r11, r8
            $RAB_STORE  rab=drive_A$RAB   ,-
                        RBF=(r8)          ,-
                        UBF=(r8)            ; set buff address
                        
            $FIND   drive_A$RAB
            bsbw    error
            $UPDATE drive_A$RAB
            bsbw    error
            addw2   #128, r5
            incl    rec_no
            sobgtr  r2, 10$                 ; loop for number of full sectors
            tstl    r4
            beql    20$
            $RAB_STORE  rab=drive_A$RAB   ,-
                        RBF=drivea_rec    ,-
                        UBF=drivea_rec      ; set buff address
                        
            movc5   r4, (r5)[r11], #^x1a, #128, drivea_rec
            $FIND   drive_A$RAB
            bsbw    error
    20$:    
            bisb2    #z80Flagm_Z, reg_F     ; set Z true
            clrb    reg_A
            brw     op_RET
            
            
OFFLOAD:    ; read BC bytes from TRK D SEC E to (HL)
            movzbl   reg_D, r2              ; Trk no
            movzbl   reg_E, r3              ; sec no
            mull2    #REC128_TRK, r2        ; trks * sec/trk
            addl3    r2, r3, rec_no
            movzwl   reg_BC, r1             ; get num bytes to write
            divl3    #128, r1, r2           ; r2 = num full sectors
            mull3    #128, r2, r3
            subl3    r3, r1, r4             ; remainder
            movzwl   reg_HL, r5
            
    10$:
            addl3   r5, r11, r8
            $RAB_STORE  rab=drive_A$RAB   ,-
                        RBF=(r8)          ,-
                        UBF=(r8)            ; set buff address
            
            $FIND   drive_A$RAB
            bsbw    error
            $GET    drive_A$RAB
            bsbw    error
            addw2   #128, r5
            incl    rec_no
            sobgtr  r2, 10$                 ; loop for number of full sectors
            
            tstl    r4
            beql    20$
            $RAB_STORE  rab=drive_A$RAB   ,-
                        RBF=drivea_rec    ,-
                        UBF=drivea_rec      ; set buffer address
            $FIND   drive_A$RAB
            bsbw    error
            $GET    drive_A$RAB
            bsbw    error
            movc3   r4, drivea_rec, (r5)[r11]
    20$:
            bisb2   #z80Flagm_Z, reg_F      ; set Z true
            clrb    reg_A
            brw     op_RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
z80config:
            ; opcode srclen.rw, srcadr.ab, fill.rb, dstlen.rw, dstadr
            movc5   #0, z80_mem_prot, #0, #^xffff, z80_mem_prot  ; Clear memory page flgs
            movc5   #0, z80_memory  , #0, #^xffff, z80_memory    ; clear z80 memory
            clrw    reg_AF
            clrw    reg_BC
            clrw    reg_DE
            clrw    reg_HL
            clrw    reg_AF2
            clrw    reg_BC2
            clrw    reg_DE2
            clrw    reg_HL2
            clrw    reg_SP
            clrw    reg_IX
            clrw    reg_IY
            clrw    reg_IR
            clrw    NEW_PC
            clrw    TEMP

            movaq   dump_z80_reg_msg_dsc, r6
            movaq   outbuf_dsc, r7
    
            movc5   DSC$W_LENGTH(r6), @DSC$A_POINTER(r6), #^A/ /, DSC$W_LENGTH(r7) , @DSC$A_POINTER(r7)

            movb    #^xFF, l^save_key(r11)  ; set l^save_key(r11) to -1
            $ASSIGN_S   chan=tt_chan, devnam=tt_nam
            bsbw     error

            $ASSIGN_S   chan=emucons_chan , devnam=emucons_nam
            bsbw     error
            
            $OPEN    drive_A$FAB
            bsbw     error
            $CONNECT drive_A$RAB
            bsbw     error
;
            $OPEN    boot$FAB
            bsbw     error
            $CONNECT boot$RAB
            bsbw     error
            movab    bootrec_str, r9
; lbs exists !=0   01=read, 10=write, 11=read+writeable  (256 byte pages)
            pushl   #3                      ; mem exists, RW
            pushl   #ram_start              ; Memory Start
            pushl   #ram_end-ram_start      ; Len Bytes
            calls   #3, z80_mem_prot_setup  ; setup the z80_mem_prot

            pushl   #1                      ; mem exists, RO
            pushl   #rom_start              ; address of z80 mem seg
            pushl   #rom_end-rom_start      ; Len Bytes z80 mem seg
            calls   #3, z80_mem_prot_setup  ; setup the z80_mem_prot

    boot_read_loop:
            ; r0  temp
            ; r7  count of data bytes in bootrec
            ; r8  index into bootrec
            ; r9  bootrec pointer
            ; r10 z80 memory index loaded from IntelHex record
            ; r11 z80 memory base
            ;
            clrl    r8
            clrb    CHKSUM         
            $GET    boot$RAB
            cmpl    r0, #RMS$_SUC
	        beql    2$
            brw     Intelhex_eof
      2$:

            ;calls   #0, ISDBG
            ;movl    r0, DFLG
            bbc     #2, DFLG, 5$
            pushaq  bootrec_dsc
            calls   #1, emuoutdsc

      5$:   cmpb    (r8)+[r9], #^A/:/
            bneq    boot_read_loop          ; skip records not begining with ':'

            bsbw    get_hex                 ; get length byte
            addb2   r0, CHKSUM              ; accumulate for chksum
            movl    r0, r7

            bsbw    get_hex                 ; get load address
            addb2   r0, CHKSUM              ; accumulate for chksum
            ashl    #8, r0, r10             ; shift byte to upper

            bsbw    get_hex                 ; load the two hex bytes into the target z80 index
            addb2   r0, CHKSUM              ; accumulate for chksum
            bisb2   r0, r10                 ; or the lower byte onto it

            bsbw    get_hex                 ; get the type
            addb2   r0, CHKSUM              ; accumulate for chksum

            caseb    r0, #0, #5
    10$:        .word Intelhex_data-10$
                .word Intelhex_eof-10$
                .word IntelHex_Extended_SegAddr-10$
                .word IntelHex_Start_SegAddr-10$
                .word IntelHex_Extended_LinearAddr-10$
                .word IntelHex_Start_LinearAddr-10$
            brw     boot_read_loop

print_nomem:                                ; print r10 z80PC is memory doesn't exist
            bsbw    errormsg_noxtmem
            brw     close_IO
            ret                             ; never reached

IntelHex_Extended_SegAddr:
IntelHex_Start_SegAddr:
IntelHex_Extended_LinearAddr:
IntelHex_Start_LinearAddr:
            brw     boot_read_loop

Intelhex_data:
    20$:    bsbw    get_hex
            addb2   r0, CHKSUM              ; accumulate for chksum
            movzbl  r0, r3                  ; save the byte

	    movzbl  z80_mem_prot[r10], r2
            blbs    r2, 22$		    ; At lease xR here we can load RAM or ROM
            bsbw    errormsg_noxtmem
	    
    22$:    movb    r3, (r10)[r11]
            bbc     #3, DFLG, 25$
            bsbw    print_loaded
    25$:    incw    r10
            sobgtr  r7, 20$                 ; loop for length

chkchksum:
            bsbw    get_hex                 ; get chksum byte in r0
            mnegb   CHKSUM, CHKSUM
            cmpb    r0, CHKSUM
            bneq    chksum_error
            brw     boot_read_loop          ; get next record
            
Intelhex_eof:
            clrl    r10                     ; PC start address
            $CLOSE  boot$FAB
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
chksum_error:
            calls    #0, clear_outbuf
            movzbl   r0,         -(sp)
            movzbl   CHKSUM,     -(sp)
            pushaq   outbuf_dsc             ; outbuf by desc
            pushaw   outbuf_dsc             ; point to length word
            pushaq   chksum_error_dsc       ; ctrstr by desc
            calls    #5, g^sys$fao
            bsbw     error
            
            pushaq   outbuf_dsc
            calls    #1, emuoutdsc
            brw      boot_read_loop

errormsg_noxtmem:
	    calls    #0, clear_outbuf
            movzwl   r10, -(sp)             ; push z80 PC
	    pushaq   outbuf_dsc	            ; outbuf by desc
            pushaw   outbuf_dsc             ; point to length word
            pushaq   noextmem_error_dsc     ; ctrstr by desc
            calls    #5, g^sys$fao
            bsbw     error

            pushaq   outbuf_dsc
            calls    #1, emuoutdsc
	    rsb
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
get_hex:    pushl   r1
            ;
            ; get byte from ascii test at address r8 where bootrec is in r9
            ; returns with result in r0 and r8 pointing to next pair of hex
            ; return 0 on error silently ignoring invalid hex digits so get it right ;)
            ;
            movzbl  (r8)+[r9], r0           ; get first nibble in r0
            subl2   #^A/0/, r0              ; adjust for '0' ascii 
            cmpl    r0, #<^A/A/-^A/0/>      ; is it less than 'A'
            blss    20$                     ; branch if 0 .. 9
            bicb2   #^x20, r0               ; upcase 
            cmpl    r0, #<^A/F/-^A/0/>      ; range check
            bleq    10$                     ; branch if A .. F
            clrl    r0                      ; error return 0
            popl    r1
            rsb
    10$:    subl2   #7, r0                  ; adjust hex digit A-F
    20$:
            movzbl  (r8)+[r9], r1           ; get next nibble
            subl2   #^A/0/, r1              ; adjust for '0' ascii
            cmpl    r1, #<^A/A/-^A/0/>      ; is it less than 'A'
            blss    40$                     ; branch if 0 .. 9
            bicb2   #^x20, r1               ; upcase
            cmpl    r1, #<^A/F/-^A/0/>      ; range check
            bleq    30$                     ; branch if A .. F
            clrl    r0                      ; error return 0
            popl    r1
            rsb
    30$:    subl2   #7, r1                  ; adjust hex digit A-F
    40$:
            mull2   #16, r0
            addl2   r1, r0
            popl    r1
            rsb
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ram_start    == ^x0000
ram_end      == ^x7FFF
rom_start    == ^xe000
rom_end      == ^xffff


z80_mem_prot_setup:
            .word ^M<r1,r2,r3,r4,r5>
            movl    0(ap),    r1            ; flags to store
            movl    4(ap),    r2            ; length of segment bytes
            movl    8(ap),    r3            ; VAX addr of start of memory seg
            
; set up rw flags on memory page
            addw3  r3, r2, r4               ; end addr in r4

    5$:     movb    r1, z80_mem_prot[r3]
            cmpw    r3, r4
            beql    10$                     ; we done
            incw    r3
            brb     5$                      ; Loop
    10$:    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
conin:
            bicb2   #z80Flagm_PV, reg_F     ; clear P flag aka V
            cmpb    l^save_key(r11), #^xFF
            bneq    10$                     ; branch if char already in save_key
            ; otherwise get one now
            $QIOW_S  efn=#1                           ,-
                    func=#IO$_READVBLK!IO$M_NOECHO    ,-
                    chan=TT_CHAN                      ,-
                    iosb=TT_IOSB                      ,-
                    p1=reg_A                          ,-
                    p2=#1                   ; request getch
            bsbw    error
            movb    reg_A, l^save_key(r11)
        
   10$:     movb    l^save_key(r11), reg_A
            movb    #^xFF, l^save_key(r11)
            bisb2   #z80Flagm_PV, reg_F     ; set P flag aka V
            brw     op_RET

const:
            cmpb    l^save_key(r11), #^xFF
            bneq    10$                     ; branch if char in buf
            ;tstb    qio_flag
            ;bneq    5$
            movb    #^xFF, l^save_key(r11)
            ;movb    #^xFF, qio_flag
            $QIO_S  efn=#1                            ,-
                    func=#IO$_READVBLK!IO$M_NOECHO    ,-
                    chan=TT_CHAN                      ,-
                    iosb=TT_IOSB                      ,-
                    p1=l^save_key(r11)                ,-
                    p2=#1                   ; request getch
            bsbw    error
            
    5$:     cmpb    l^save_key(r11), #^xFF  ; did we get a char?
            beql    20$                     ; branch yes
    10$:    movb    #^xFF, reg_A            ; tell them we got a char
            bicb2   #z80Flagm_Z, reg_F      ; clear Z flag
            ;clrb    qio_flag               ; qio must  have completed
            brb     30$
            
    20$:    clrb    reg_A                   ; tell them no char
            bisb2   #z80Flagm_Z, reg_F      ; set Z flag
    30$:
            brw     op_RET
            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
conout:
            pushl   r0
            pushl   r1

            $QIOW_S efn=#2                ,-
                    func=#IO$_WRITEVBLK   ,-
                    chan=TT_CHAN          ,-
                    iosb=TT_IOSB          ,-
                    p1=reg_C              ,-
                    p2=#1
            bsbw    error
            popl    r1
            popl    r0
            brw     op_RET
            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
error:
            blbs    r0, 10$
            $exit_s r0
    10$:
            rsb


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
clear_outbuf: .word ^M<r0,r1, r2, r3, r4, r5>
            movaq    outbuf_dsc, r5
            movw     #outbuf$S_LEN, DSC$W_LENGTH(r5) ; set the initial length to max
            movc5    #0, @DSC$A_POINTER(r5), #0, DSC$W_LENGTH(r5), @DSC$A_POINTER(r5) ; zerofill
            ret
            

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
setflagsstr:
            ; r0   flags
            ; r1   addr of str
            movl     #^A/__0_/  ,  (r1)
            movl     #^A/0___/  , 4(r1)
            bbc      #0, r0, 10$
            movb     #^A/C/, 7(r1)          ; Carry Set
     10$:   bbc      #1, r0, 20$
            movb     #^A/N/, 6(r1)          ; Negative Set
     20$:   bbc      #2, r0, 30$
            movb     #^A/V/, 5(r1)          ; P/V Parity/oVerflow set
     30$:   bbc      #3, r0, 40$
            movb     #^A/3/, 4(r1)          ; unused 3
     40$:   bbc      #4, r0, 50$
            movb     #^A/H/, 3(r1)          ; Half carry set
     50$:   bbc      #5, r0, 60$
            movb     #^A/5/, 2(r1)          ; unused 5
     60$:   bbc      #6, r0, 70$
            movb     #^A/Z/, 1(r1)          ; Zero flag set
     70$:   bbc      #7, r0, 80$
            movb     #^A/S/, 0(r1)          ; Sign flag set
     80$:   rsb

;######################################################################
;# input  r0 opcode
;# result r2
;# 
XXrrrxxx:
;	    .show EXPANSIONS
            extzv   #4, #2, r0, r1          ; get reg pair addr
            movl    ptr_AF,     r3          ; get assume its ptr reg_A
            cmpb    r1, #3                  ; is it indirect (IDX/ A
            bneq    12$                     ; branch if not (IDX)/ A

	    ; 11x A or (IDX)
            movl    r3,         r2
            bbs     #3, r0, 15$             ; branch if 111 reg A

            ; else its 110 Indirect (IDX)  ie (HL) (IX+d) (IY+d)
            movl    ptr_IDX,    r3          ; VAX addr of 16bit reg
            movzwl  (r3),       r2          ; z80 addr val of IDX in r2
            cmpl    r9,         r3          ; is it the addr of HL else indexes
            beql    10$                     ; branch if HL

            ;NO its IX or IY so fetch d
            ; fetch byte from PC
            clrl                r3
            cvtbw   (r10)[r11], r3          ; else fetch offset d
            incw     r10

            addw2   r3,         r2          ; add offset d IX/IY+d

       10$: movab   (r2)[r11],  r2          ; cvt z80 address in r2 to vax
            brb     20$

    12$:    ; else its BC, DE or IDX
            movl    ptr_BC[r1], r3          ; get VAX address of reg pair

	    cmpzv   #6, #2, r0, #1          ; only for LD r,r'
            bneq    13$

            cmpzv   #1, #2, r0, #3          ; get src reg pair addr is the other (hl) hl indirect ?
	    bneq    13$
            movl    ptrn_BC[r1], r3         ; get hl direct reg pair ie ld L, (IX+3)
    13$:   
            movl    r3,         r2
            bbs     #3, r0, 20$             ; branch if lower 8 bit reg

    15$:    incl                r2          ; move ptr to upper 8 bit reg

    20$:
	    .noshow EXPANSIONS
	    rsb
;.endm




;######################################################################
;# input r0 opcode
;# result r2
;# 
;.macro  XXxxxrrr
XXxxxrrr:
	    ;.show EXPANSIONS
            extzv   #1, #2, r0, r1          ; get reg pair addr
            movl    ptr_AF,     r3          ; get assume its ptr reg_A
            cmpb    r1, #3                  ; is it indirect (IDX/ A
            bneq    12$                     ; branch if not (IDX)/ A

	    ; 11x A or (IDX)
            movl    r3,         r2
            blbs    r0, 15$                 ; branch if 111 reg A

            ; else its 110 Indirect (IDX)  ie (HL) (IX+d) (IY+d)
            movl    ptr_IDX,    r3          ; VAX addr of 16bit reg
            movzwl  (r3),       r2          ; z80 addr val of IDX in r2
            cmpl    r9,         r3          ; is it the addr of HL else indexes
            beql    10$                     ; branch if HL

            ;NO its IX or IY so fetch d
            ; fetch byte from PC
            clrl                r3
            cvtbw   (r10)[r11], r3          ; else fetch offset d
            incw     r10

            addw2   r3,         r2          ; add offset d IX/IY+d

       10$: movab   (r2)[r11],  r2          ; cvt z80 address in r2 to vax
            brb     20$

    12$:    ; else its BC, DE or IDX
            movl    ptr_BC[r1], r3          ; get VAX address of reg pair

	    cmpzv   #6, #2, r0, #1          ; only for LD r,r'
            bneq    13$

            cmpzv   #4, #2, r0, #3          ; get otherside reg index is the other (hl) indirect ?
	    bneq    13$
            movl    ptrn_BC[r1], r3         ; use direct HL if its H or L
    13$:   

            movl    r3,         r2
            blbs    r0, 20$                 ; branch if lower 8 bit reg

    15$:    incl                r2          ; move ptr to upper 8 bit reg

    20$:    
	    ;.noshow EXPANSIONS
	    rsb
;.endm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


traceit: 
	    tstl    TRACEDEPTH
	    beql    trcon	            ; always trace for level 0
	    cmpl    CALLDEPTH, TRACEDEPTH
	    blss    trcon
   troff:   ; stop/dont trace anymore
            brw   outdot                    ; return via outdot
            
   trcon:
	    tstl    DOTS
	    beql    trstart                 ; not previously outputing dots
	    bsbw    newline
            clrl    DOTS

   trstart: tstl    DFLG
	    bneq    dotrace                 ; return via dotrace
            rsb
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
dotrace:
	    cmpw    #^A/DI/, ID		    ; word order is ID
	    bneq    dotraceDI
;;;;;;;;;;
dotraceID:
            blbc    DFLG, 5$
            bsbb    disassembler

   5$:      bbc     #1, DFLG, 10$           ; don't dump regs for nop
            bsbb    dump_z80_reg
   10$:     rsb

;;;;;;;;;;
dotraceDI:
            bbc     #1, DFLG, 5$           ; don't dump regs for nop
            bsbb    dump_z80_reg

   5$:      blbc    DFLG, 10$
            bsbb    disassembler
   10$:     rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
disassembler:
            pushl   r0                      ; save opcode
            movzwl  CURIP, r0
            pushl   r0
            pushal  z80_memory
            calls   #2, diz80
            popl    r0                      ; restore opcode
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
dump_z80_reg:
            pushl    r0
            pushl    r1
            pushl    r2

            calls    #0, clear_outbuf

            movzbl   reg_F      , r0
            movab    flag1_str  , r1
            bsbw     setflagsstr

            movzbl   reg_F2     , r0
            movab    flag2_str  , r1
            bsbw     setflagsstr

            movzwl   reg_IR     , -(sp)     ;1 

            movzwl   reg_SP     , r2
; dump 3 top stack items
            movzwl   r2         , -(sp)     ;2
            movb     (r2)[r11]  , DMPTMP
            incw     r2
            movb     (r2)[r11]  , DMPTMP+1
            incw     r2
            movzwl   DMPTMP     , -(sp)     ;3

            movzwl   r2         , -(sp)     ;4
            movb     (r2)[r11]  , DMPTMP
            incw     r2
            movb     (r2)[r11]  , DMPTMP+1
            incw     r2
            movzwl   DMPTMP     , -(sp)     ;5

            movzwl   r2         , -(sp)     ;6
            movb     (r2)[r11]  , DMPTMP
            incw     r2
            movb     (r2)[r11]  , DMPTMP+1
            incw     r2
            movzwl   DMPTMP     , -(sp)     ;7

            movzwl   reg_SP     , -(sp)     ;8

            movzwl   reg_IY     , r2
            movzbl   (r2)[r11]  , -(sp)     ;9 byte at 
            pushl    r2                     ;10

            movzwl   reg_IX     , r2
            movzbl   (r2)[r11]  , -(sp)     ;11 byte at 
            pushl    r2                     ;12

            movzwl   reg_HL2    , r2
            movzbl   (r2)[r11]  , -(sp)     ;13 byte at 
            pushl    r2                     ;14

            movzwl   reg_HL     , r2
            movzbl   (r2)[r11]  , -(sp)     ;15 byte at 
            pushl    r2                     ;16

            movzwl   reg_DE2    , r2
            movzbl   (r2)[r11]  , -(sp)     ;17 byte at 
            pushl    r2                     ;18

            movzwl   reg_DE     , r2
            movzbl   (r2)[r11]  , -(sp)     ;19 byte at 
            pushl    r2                     ;20

            movzwl   reg_BC2    , r2
            movzbl   (r2)[r11]  , -(sp)     ;21 byte at 
            pushl    r2                     ;22

            movzwl   reg_BC     , r2
            movzbl   (r2)[r11]  , -(sp)     ;23 byte at 
            pushl    r2                     ;24

            pushaq   flag2_dsc              ;25
            movzwl   reg_AF2    , -(sp)     ;26

            pushaq   flag1_dsc              ;27
            movzwl   reg_AF     , -(sp)     ;28
            ; we called before executing or increment PC thus
            ; PC in r10 is the curent to dispatch address
            movl     CURIPADDR  , r0
            movzbl   (r0)       , -(sp)     ;29 current opcode
            pushl    CURIP                  ;30 PC
            pushaq   outbuf_dsc             ;31 outbuf by desc
            pushaw   outbuf_dsc             ;32 outbuf len by addr
            pushaq   dump_z80_reg_msg_dsc   ;33 ctrstr by desc
            calls    #33, g^sys$fao
            bsbw     error
            
            pushaq   outbuf_dsc
            calls    #1, G^LIB$PUT_OUTPUT
            ;calls    #1, emuoutdsc

            popl     r2
            popl     r1
            popl     r0
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
halt_message:
            bsbw    dump_z80_reg
            pushaq  halt_prompt_dsc
            calls   #1, emuoutdsc
            $exit_s r0
            bsbw    emugetc
            clrb    runflag
            brw     fetch

unknown_op:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;            movzbl   -1(r10)[r11], -(sp)    ; opcode
;            pushaq   outbuf_dsc             ; outbuf by desc
;            pushaw   outbuf_dsc;
;            pushaq   err_unknown_op_dsc     ; ctrstr by desc
;            calls    #4, g^sys$fao
;            bsbw     error
;            pushaq   outbuf_dsc
;            calls    #1, emuoutdsc
;            bsbw     error
             brw      fetch
            
newline:
	     pushl    r0
	     movb     #^x0A , emucons_iochar
	     bsbb      emuout
	     movb     #^x0D , emucons_iochar
	     bsbb      emuout
	     popl     r0
	     rsb


outdot:
	     incl     DOTS
	     pushl    r0
	     movb     #^A/./ , emucons_iochar
	     bsbb      emuout
	     popl     r0
	     rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emuoutc:                                    ; write emulator console
            movb    r0, emucons_iochar
emuout:    
            pushl   r1
	    $QIOW_S efn=#42              ,-
                    func=#IO$_WRITEVBLK  ,-
                    chan=emucons_chan    ,-
                    iosb=emucons_iosb    ,-
                    p1=emucons_iochar    ,-
                    p2=#1
            bsbw    error
            popl    r1
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emugetc:                                    ; read  emulator console
            $QIOW_S efn=#43                         ,-
                    func=#IO$_READVBLK!IO$M_NOECHO  ,-
                    chan=emucons_chan               ,-
                    iosb=emucons_iosb               ,-
                    p1=emucons_iochar               ,-
                    p2=#1                   ; request getch
            bsbw    error
            movzbl  emucons_iochar, r0
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emuoutdsc:  .word ^M<r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
            ; print str at descriptor 4(ap)
            movl     4(ap), r5
            movl     DSC$A_POINTER(r5), r1
            movzwl   DSC$W_LENGTH(r5),  r2
            bsbw     emuoutstr
            ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emuoutstr:  ; r1 = addr of string
            ; r2 = len
   10$:     movb   (r1)+, r0
            bsbw   emuoutc
            sobgtr r2, 10$
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emuout_newline:
            pushl   r0
            movzwl  #^X0A, r0
            bsbw    emuoutc
            movzwl  #^X0D, r0
            bsbw    emuoutc
            popl    r0
            rsb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
print_loaded: ; display loaded byte from r3 to r10
            pushl r3
            pushl r10

            calls    #0, clear_outbuf
            movzbl   r3,  -(sp)
            movzwl   r10, -(sp)
            pushaq   outbuf_dsc             ; outbuf by desc
            pushaw   outbuf_dsc             ; outbuf len by ref
            pushaq   loaded_dsc             ; ctrstr by desc
            calls    #5, g^sys$fao
            bsbw     error

            pushaq   outbuf_dsc
            calls    #1, emuoutdsc

            popl     r10
            popl     r3
            rsb

            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
close_IO:
            $DASSGN_S  chan=tt_chan
            $DASSGN_S  chan=emucons_chan
            $CLOSE     drive_A$FAB
            bsbw       error
            movl       s^#SS$_NORMAL, r0
            ret        ; exit to VMS

            .end z80_start
