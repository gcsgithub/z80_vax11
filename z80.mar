	.title z80-emulator
	.ident /160989/
;
; (c) Copyright 1989 Mark Garrett
;
; 	You may use this program freely, You may not sell it. If you improve or change this program in
; any way IÕd appreciate that you send me your changes, and make proper comments in the source code indicating thee changes.
;
;	I MAKE NO REPRESENTATIONS ABOUT THE SUITABILITY OF
;	THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED ÒAS ISÓ 
;	WITH OUT EXPRESSED OR IMPLIED WARRANTY OF ANY KIND.
;	I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE,
;	INCLUDING ALL IMPLIED WARRANTES OF MERCHANTABILITY AND FITNESS
;	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL I, BE LIABLE FOR ANY 
;	SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
;	OR PROFITS, WHETHER IN ANY ACTION OF CONTRACT, NEGLIGENCE
;	OR OTHER TORTIOUS ACTION, ARISING OUT OF OR INCONNECTION
;	WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
;
;	I hope that covers the copyright bit. I knew I should have
;	gone to law school but computers seem more fun..
;
; 2013 fix long standing error in pun and rdr rabs
;       add support for halt loop with prompt to exit, incomplete
;
;
; This program will emulate a micro computer based on :-
; CPU	= z80
; OS	= CP/M
; CRT	= ANSI (vt100)
;
;
$iodef
$ttdef
            .psect z80$FILE_CONTROL	LONG,WRT,noexe

;
OUT$FAB:	$FAB	FAC=<PUT>		,-
			RFM=<VAR>               ,-
			SHR=<NIL>               ,-
			FNM=<SYS$OUTPUT>
;
OUT$RAB:	$RAB	FAB=OUT$FAB		,-
			RAC=<SEQ>               ,-
			RBF=OUT$A_RECORD        ,-
			RSZ=OUT$S_RECORDSIZE	,-
			UBF=OUT$A_RECORD        ,-
			USZ=OUT$S_RECORDSIZE
;
pun$FAB:	$FAB	FAC=<PUT>		,-
			RFM=<VAR>               ,-
			SHR=<NIL>               ,-
			FNM=<z80$pun>
;
pun$RAB:	$RAB	FAB=pun$FAB		,-
			RAC=<SEQ>               ,-
			RBF=pun$rec             ,-
			RSZ=256                 ,-
			UBF=pun$rec             ,-
			USZ=256
;
rdr$FAB:	$FAB	FAC=<GET>		,-
			RFM=<VAR>               ,-
			SHR=<NIL>               ,-
			FNM=<z80$rdr>
;
rdr$RAB:	$RAB	FAB=rdr$FAB		,-
			RAC=<SEQ>               ,-
			RBF=rdr$rec             ,-
			RSZ=256                 ,-
			UBF=rdr$rec             ,-
			USZ=256
;
lpt$FAB:	$FAB	FAC=<PUT>		,-
			RFM=<VAR>               ,-
			SHR=<NIL>               ,-
			FNM=<z80$lpt>
;
lpt$RAB:	$RAB	FAB=lpr$FAB		,-
			RAC=<SEQ>               ,-
			RBF=lpt$rec             ,-
			RSZ=132                 ,-
			UBF=lpt$rec             ,-
			USZ=132
;
boot$FAB:	$FAB	FAC=<GET>		,-
			RFM=<VAR>               ,-
			SHR=<NIL>               ,-
			FNM=<bootrom.hex>
;
boot$RAB:	$RAB	FAB=boot$FAB	,-
			RAC=<SEQ>               ,-
			RBF=bootrec             ,-
			RSZ=256                 ,-
			UBF=bootrec             ,-
			USZ=256
;
drive_A$FAB:	$FAB	FAC=<PUT,GET,UPD>	,-
			SHR=<NIL>               ,-
			ORG=<REL>               ,-
			RFM=<FIX>               ,-
			FNM=<DRIVE$A>           ; assign logical
;
drive_A$RAB:	$RAB	FAB=drive_A$FAB		,-
			RAC=<KEY>               ,-
			KRF=0                   ,-
			KBF=REC_NO              ,-
			KSZ=4                   ,-
			RBF=DRIVEA_REC          ,-
			RSZ=128                 ,-
			UBF=DRIVEA_REC          ,-
			USZ=128
REC128_TRK==37

		.psect file$data	rd, wrt, noexe
REC_NO:		.BLKL	1
lprptr:		.blkw	1
punptr:		.blkw	1
rdrptr:		.blkw	1

lpr$rec:	.blkb	256
pun$rec:	.blkb	256
rdr$rec:	.blkb	256

bootrec:	.blkb	128
drivea_rec:	.blkb	128

runflag:    .byte   0           ; run while 0

hlt_mess:	.ascid -
" Z80 halted at address !4XW!/"-
"	AF = !4XW		AF' = !4XW!/"-
"	BC = !4XW		BC' = !4XW!/"-
"	DE = !4XW		DE' = !4XW!/"-
"	HL = !4XW		HL' = !4XW!/"-
"		IX = !4XW!/"-
"		IY = !4XW!/"-
"		SP = !4XW!/"-
"		IR = !4XW!/"


outbuf:	.long	 out$s_recordsize
		.address out$a_record


$EQU	OUT$S_RECORDSIZE	<80 * 25>
$DEF	OUT$A_RECORD		.BLKB <OUT$S_RECORDSIZE>

; moveab buffer, drive_a$rab+rab$l_ubf
;
;
;
            .psect z80$data	noexe,rd,wrt,pic

qio_flag	.blkb	1

tt_nam:		.ascid /TT/
tt_chan:	.blkw	1
tt_iosb:	.blkq	1
tt_buf:		.blkb	1
;save_key:	.blkb	1

            .psect z80$registers	noexe,rd,wrt,pic,long
ptr_AF:		.address	reg_AF
ptr_BC:		.address	reg_BC
ptr_DE:		.address	reg_DE
ptr_IDX:	.address	reg_HL
ptr_SP:		.address	reg_SP


reg_AF:
	reg_F:	.blkb	1
	reg_A:	.blkb	1
reg_BC:
	reg_C:	.blkb	1
	reg_B:	.blkb	1
reg_DE:
	reg_E:	.blkb	1
	reg_D:	.blkb	1
reg_HL:
	reg_L:	.blkb	1
	reg_H:	.blkb	1


reg_AF2:
	reg_F2:	.blkb	1
	reg_A2:	.blkb	1
reg_BC2:
	reg_C2:	.blkb	1
	reg_B2:	.blkb	1
reg_DE2:
	reg_E2:	.blkb	1
	reg_D2:	.blkb	1
reg_HL2:
	reg_L2:	.blkb	1
	reg_H2:	.blkb	1

reg_SP:
	reg_SPL: .blkb	1
	reg_SPH: .blkb  1
reg_IX:
	reg_IXL: .blkb	1
	reg_IXH: .blkb  1
reg_IY:
	reg_IYL: .blkb	1
	reg_IYH: .blkb  1

reg_IR:
	reg_R:	.blkb	1
	reg_I:	.blkb	1

TEMP_PC:	.BLKW	1
TEMP:		.blkw	1

EBREAK:		.BLKW	1

LBREAK1:	.word	^x0080	; Break start of rom
HBREAK1:	.word	^x0200	; Break up to the end of rom

LBREAK2:	.word	^x0080	; Break start of rom
HBREAK2:	.word	^x0200	; Break up to the end of rom

save_key == ^x0DF60

z80_memory:	.blkb ^xffff
;
;	R9 holds address of HL reg pair
;	r1 holds the memory address last accessed when looping back to fetch
; ZPC=R10
; zmem=R11

		.psect	z80$emulator	exe,nowrt,pic
Z80_START::	.word ^M<>
            movab	z80_memory, r11
            bsbw	SETUPIO
            clrw	reg_SP
            movaw	reg_HL, r9

fetch:      movaw reg_HL, ptr_idx

fetch2:     movzbl	(r10)[r11], r0
            cmpw	r10, EBREAK
            beql	break1

            cmpw	r0, LBREAK1
            blss	test2		; branch if less that low break
            cmpw	r10, HBREAK1
            bgtr	test2		; branch if greater than High Break
            brb     break1

test:       cmpw    r10, LBREAK2
            blss    fetched
            cmpw    r10, HBREAK2
            bgtr    fetched

BREAK1:     nop                 ; set a break here
            blbc    runflag, fetched
            brw     halt

fetched:
            incw    r10         ; inc z80pc
;   
            extzv   #0, #3, r0, r2
            extzv   #6, #2, r0, r1
            beql    op00
        
            cmpb    r1, s^#02
            blss    op_01
            beql    op_10
            ;bgtr   op_11
op_11:      brw     op11
op_01:      brw     op01
op_10:      brw     op10

op00:       caseb   r2, #0, #7
        10$:        .word op_00_000-$10
                    .word op_00_001-$10
                    .word op_00_010-$10
                    .word op_00_011-$10
                    .word op_00_100-$10
                    .word op_00_101-$10
                    .word op_00_110-$10
                    .word op_00_111-$10

op00_000:   extzv   $3, #3, r0, r1
            movzbl  (r10)[r11], r3      ; fetch branch value
            incw    r10
            
            caseb   r1, #0, #7
        10$:        .word op00_000_000-10$      ; NOP
                    .word op00_000_001-10$      ; EX AF, AF'
                    .word op00_000_010-10$      ; DJNZ  e
                    .word op00_000_011-10$      ; JR    e
                    .word op00_000_100-10$      ; JR    NZ, e
                    .word op00_000_101-10$      ; JR     Z, e
                    .word op00_000_110-10$      ; JR    NC, e
                    .word op00_000_111-10$      ; JR     C, e

op00_000_000:   ; NOP
            decw    r10 ; restore r10 branch not part of NOP
            brw     fetch

op00_000_001:   ; EX AF, AF'
            decw    r10 ; restore r10 bratch not part of EX
            movw    reg_AF, r0
            movw    reg_AF2, reg_AF
            movw    r0, reg_AF2
            brw     fetch

op00_000_010:   ; DJNZ e
            decb    reg_B
            beql    lab01   ; branch if loop is finished
op00_000_011:   ; JR    e
            addb2   r3, r10
lab01:      brw     fetch


op00_000_100:   ; JR    NZ, e
            bbc     #6, reg_F, op00_000_011
            brw     fetch
op00_000_101:   ; JR    Z, e
            bbs     #6, reg_F, op00_000_011
            brw     fetch
        
op00_000_110:   ; JR    NC, e
            bbc     #0, reg_F, op00_000_011
            brw     fetch
op00_000_111:   ; JR     C, e
            bbs     #0, reg_F, op00_000_011
            brw     fetch
                
		
;----------------------
op00_001:   extzv   #4, #2, r0, r3
            bbs     #3, r0, ADD_HL
LD_HL:      ; LD rr, nn
            movb    (r10)[r11], TEMP
            invw    r0
            movb    (r10)[r11], TEMP+1
            incw    r10
            movl    PTR_BC[r3], r2
            movw    TEMP, (r2)
            
            brw     fetch
            
ADD_HL:     ; ADD HL, rr or ADD IX, rr or ADD IY, rr
            movl    ptr_bc[r2[, r2
            addw2   (r2), @ptr_idx
            bcc     10$
            bisb2   #^x01, reg_F        ; set z80 carry flag
                                        ; TODO: check 2013 do we need to also clear?
    10$:    brw     fetch
;------------------------
;
op00_010:   ; 00, 01 = LD (BC, DE), A / LD A, (BC, DE)
            ; 10 = LD (nn), HL / LD HL, (nn)
            ; 11 = LD (nn), A  / LD A, (nn)
            extzv   #4, #2, r0, r3
            cmpb    r3, #2
            blss    20$                 ; branch if 00, 01
            movb    (r10)[r11], TEMP    ; fetch nn to TEMP
            incw    r10
            movb    (r10)[r11], TEMP+1
            incw    r10
            movzwl  TEMP, r1
            addl3    r11, r1, r2        ; make address vax relative
            cmpb    r3, #3
            beql    15$                 ; branch if 11
            movl    ptr_idx, r4
            brb     30$
    15$:    movaw   reg_A, r4
            brb     30$
    20$:    ; 00, 01
            movl    ptr_BC[r3], r1
            addl3   r11, r1, r2         ; make vax relative
            movaw   reg_A, r4
    30$:    cmpb    r3, #2
            beql    m16bit
            ; 8 bit move 00, 01, 11
            bbs     #3, r0, 40$
            movb    (r4), (r2)
            brw     fetch
        
    40$:    movb    (r2), (r4)
            brw     fetch
            
            
m16bit:     bbs     #3, r0, 10$
            movb    (r4), (r2)+         ; points to a register
            incw    r4
            movb    (r4), (r2)
            brw     fetch
            
    10$:    movb    (r2)+, (r4)         ; r2 points to a register
            incw    r4
            movb    (r2), (r4)
            brw     fetch
            
op00_011:
            extzv   #4, #2, r0, r3      ; INC/DEC rr
            movl    ptr[BC], r3, r2
            bbs     #3, r0, DECrr
            incw    (r2)
            brw     fetch
DECrr:      decw    (r2)
            brw     fetch
            
op00_100:                               ; INC r
            extzv   #4, #2, r0, r3      ; get reg pair addr
            cmpb    r3, #3              ; is it (IDX) or A
            bneq    12$                 ; branch if not
            bbs     #3, r0, 15$         ; branch if reg A
            movzwl  @ptr_IDX, r1        ; else if (HL) or (IX+d) or (IY+d)
            cmpl    r9, ptr_IDX         ; is HL or indexs
            beql    10$                 ; branch if HL
            movzbl  (r10)[r11], r2      ; else fetch offset d
            incw    r10
            addb2   r2, r1              ; add offset d
    10$:    addl3   r11, r1, r2         ; cvt z80 address to vax
            brb     20$
    12$:    ; its BC, DE or IDX
            movl    ptr_BC[r3], r2      ; get address of reg pair
            bbs     #3, r0, 20$         ; branch if lower 8 bit reg
            brb     17$
    15$:    ; its A reg
            movl    ptr_AF, r2          ; get address of reg_AF
    17$:    incl    r2                  ; move ptr to upper 8 bit reg
    20$:    movzbl  (r2), r0
            incb    (r2)
            movpsl  r3
            bicb2   #^XD6, reg_F        ; clear S, Z, H, V, N flags
            bcc     #1, r3, 21$
            bisb2   #^x02, reg_F        ; set V flag
    21$:    bcc     #2, r3, 22$
            bisb2   #^x40, reg_F        ; set Z flag
    22$:    bbc     #3, r3, 23$
            bisb2   #^x80, reg_F        ; set S flag
    23$:    bicb2   #^xF0, r0           ; clear upper nibble
            incb    r0
            cmpb    r0, #16
            bleq    24$                 ; branch if no half carry
            bisb2   #^x10, reg_F        ; set H flag
    24$:    brw     fetch
    
op00_101:                               ; DEC r
            extzv   #4, #2, r0, r3      ; get reg pair addr
            cmpb    r3, #3              ; is it (IDX) or A ?
            bneq    12$                 ; branch if not
            bbs     #3, r0, 15$         ; branch if reg A
            movzwl  @ptr_IDX, r1        ; else is (HL) or (IX+d) or (IY+d)
            cmpl    r9, ptr_IDX         ; is HL or indexs?
            beql    10$                 ; branch if HL
            movabl  (r10)[r11], r2      ; else fetch offset d
            incw    r10
            addb2   r2, r1              ; add offset
    10$:    addl3   r11, r1, r2         ; cvt z80 to VAX address
            brb     20$
    12$:    ; irs BC, DE or IDX
            movl    ptr_BC[r3], r2      ; get address of reg pair
            bbs     #3, r0, 20$         ; branch if lower 8 bit reg
            brb     17$
    15$:    ; its  reg
            movl    ptr_AF, r2          ; get address of reg AF
    17$:    incl    r2                  ; move ptr to upper 8 bit reg
    20$:    movzbl  (r2), r0
            decb    (r2)
            movpsl  r3
            bicb2   #^xD6, reg_F        ; clear S, Z, H, V, N Flags
            bisb2   #^x02, reg_F        ; set N flag
            bbc     #1, r3, 21$
            bisb2   #^x02, reg_F        ; set V flag
    21$:    bbc     #2, r3, 22$
            bisb2   #^x40, reg_F        ; set Z flag
    22$:    bbc     #3, r3, 23$
            bisb2   #^x80, reg_F        ; set S flag
    23$:    bicb2   #^xF0, r0           ; clar upper nibble
            decb    r0
            cmpb    r0, #^x0f
            bleq    24$                 ; branch if no half carry
            bisb2   #^x10, reg_F        ; set H flag
    24$:    brw     fetch
    
op00_110:                               ; LD r, n
            extzv   #4, #2, r0, r3      ; get reg pair addr
            cmpb    r3, #3              ; is it (IDX) or A
            bneq    12$                 ; branch if not
            bbs     #3, r0, 15$         ; branch if reg A
            movzwl  @ptr_IDX, r1        ; else is (HL) or (IX+d) or (IY+d)
            cmpl    r9, ptr_IDX         ; is HL or indexs
            beql    10$                 ; branch if HL
            movzbl  (r10)[r11], r2      ; else fetch offset d
            incw    r10
            addb2   r2, r1              ; add offset d
    10$:    addl3   r11, r1, r2         ; cvt z80 to vax addr
            brb     20$
    12$:    ; its BC DE or IDX
            movl    ptr_BC[r3], r2      ; get address of reg pair
    14$:    bbs     #3, r0, 20$         ; branch if lower 8 bit reg
            brb     17$
    15$:    ; its A reg
            movl    ptr_AF, r2          ; get address of reg AF
    17$:    incl    r2                  ; move ptr to upper 8 bit reg
    20$:    movb    (r10)[r11], (r2)    ; fetch n and store
            incw    r10
            brw     fetch
            
op00_111:   ; RLCA, RRCA, RLA, RRA, DAA, CPL, SCF, CCF
            extzv   #3, #3, r0, r2
            caseb   r2, #0, #7
    10$:        .word   op00_111_000-10$         ; RLCA
                .word   op00_111_001-10$         ; RRCA
                .word   op00_111_010-10$         ; RLA
                .word   op00_111_011-10$         ; RRA
                .word   op00_111_100-10$         ; DAA
                .word   op00_111_101-10$         ; CPL
                .word   op00_111_110-10$         ; SCF
                .word   op00_111_111-10$         ; CCF
                
op00_111_000:                           ; RLCA
            movzbl  reg_A, r2
            ashl    #1, r2, r2
    lab02:  bbc     #8, r2, 10$         ; branch if no carry
            bisb2   #^x01, reg_F        ; else set carry
            bisb2   #^x01, r2
    10$:    movb    r2, reg_A
            bicb2   #^x12, reg_F        ; clear H, N flags
            brw     fetch
            
op00_111_001:                           ; RRCA
            movzbl  reg_A, r2
            ashl    #-1, r2, r2
            brb     lab02
            
op00_111_010:                           ; RLA
            movzbl  reg_A, r2
            ashl    #1, r2, r2
            blbc    reg_F, 10$          ; test z80 C_flag
            bisb2   #^x01, r2           ; C was set
    10$:    bbc     #8, r2, 20$         ; test for carry
            bisb2   #^x01, reg_F        ; set Z80 C_flag
    20$:    movb    r2, reg_A
            bicb2   #^x12, reg_F        ; clear H, N flags
            brw     fetch
            
            
op00_111_011:                           ; RRA
            movzbl  reg_A, r2
            ashl    #-1, r2, r3
            blbc    reg_F, 10$          ; branch if NC
            bisb2   #^x80, r3           ; C -> bit7
    10$:    blbc    r2, 20$             ; branch if no bit to carry
            bisb2   #^x01, reg_F        ; bit0 -> C
    20$:    bicb2   #^x12, reg_F        ; clear H, N
            movb    r3, reg_A
            brw     fetch
            
            
op00_111_100:                           ; DAA
            movzbl  reg_A, r2
            extzv   #0, #4, r2, r4      ; get lower nibble
            extzv   #4, #4, r2, r3      ; get upper nibble
            bbs     #1, reg_F, DAA_SUB
;DAA_ADD:
            cmpb    r4, #^x09
            bgtr    10$                 ; branch if >9
            bbc     #4, reg_F, 20$      ; branch if no add required
    10$:    addb2   #^x06, r2           ; add to byte
            addb2   #^x06, r4           ; add to lower nibble
            bicb2   #^x10, reg_F        ; clear H flag
            cmpb    r4, #^x0f           ; check for half carry
            bleq    20$                 ; branch if no half carry
            bisb2   #^x10, reg_F        ; set half carry
            incb    r3                  ; add 1 to upper nibble
    20$:    cmpb    r3, #^x09
            bleq    40$                 ; branch if add no req (<=9)
            blbc    reg_F, 40$          ; branch if NC
            addb3   #^x60, r2, reg_A    ; add to byte
    40$:    movpsl  r3
    
daa_setflags:
            bicb2   #^xc5, reg_F        ; clear S, Z, V, C
            blbc    r3,     31$
            bisb2   #^x01, reg_F        ; set C flag
    31$:    bbc     #1, r3, 32$
            bisb2   #^x04, reg_F        ; set V flag
    32$:    bbc     #2, r3, 33$
            bisb2   #^x40, reg_F        ; set Z flag
    33$:    bbc     #3, r3, 34$
            bisb2   #^x80, reg_F        ; set S flag
    34$:    brw     fetch
    
DAA_SUB:    ; r2 = byte r3 = Hnibble r4 = Lnibble
            bbc     #4, reg_F, 10$      ; branch if NO half borrow
            subb2   #^x06, r2           ; sub 6 from byte
            subb2   #^x06, r4           ; sub 6 from lower nibble
            cmpb	r4, #^x0f
            bleq	10$					; branch if no half borrow
            bisb2	#^x10, reg_F		; set half borrow
    10$:	blbc	reg_F, 20$			; branch if no borrow
    		subb2	#^x60, r2			; sub from byte
    20$:	movb	r2, reg_A
    		brb		daa_set_flags
    		
op00_111_101:							; CPL complement A
			mcomb	reg_A, reg_A
			bisb2	#^x12, reg_F		; set H & N flags
			brw		fetch
			
op00_111_110:							; SCF set carry flag
			bisb2	#^x01, reg_F		; set carry
			bicb2	#^x12, reg_F		; clear H & N flags
			brw		fetch
			
op00_111_111:							; CCF complement carry flag
			blbc	reg_F, op00_111_110	; set carry flag
			bicb2	#^x03, reg_F		; clear C & N
			brw		fetch
			
;-----------------------------------------------------------------------
halt:		movb    #^s1,       runflag ; set the halt flag
            brw     halt_message            ; must continue via brw fetch
op01:									; LD r, rÕ
			cmpb	r0, #^x76			; is it HALT?
			beql	halt
;
dest:		extzv	#4, $2, r0, r3		; get dest reg pair addr
			cmpb	r3, #3				; is it (IDX) or A
			bneq	12$					; branch if not
			bbs		#3, r0, 15$			; branch if reg A?
			movzwl	@ptr_IDX, r1		; else is (HL) or (IX+d) or (IY+d)
			cmpl	r9, ptr_IDX			; is HL or indexs
			beql	10$					; branch if HL
			movzbl	(r10)[r11], r2		; esel fetch offset d
			incw	r10
			addb2	r2, r1
	10$:	addl3	r11, r1, r2			; cvt z80 address to vax
			brb		20$
	12$:	; irs BC DE or IDX
			movl	ptr_BC[r3], r2		; get address of reg pair
			bbs		#3, r0, 20$			; branch if lower 8 bit reg
			brb		17$
	15$:	; its A reg
			movl	ptr_AF, r2			; get address of reg AF
	17$:	incl	r2					; move ptr to upper 8 bit reg
	20$:	movl	r2, r4				; get dest address in r4

src1:		extzv	#1, #2, r0, r3		; get src reg pair addr
			cmpb	r3, #3				; is it (IDX) or A?
			bneq	12$					; branch if not
			bbs		#0, r0, 15$			; branch if reg A
			movzwl	@ptr_IDX, r1		; else if (HL) or (IX+d) or (IY+d)
			cmpl	r9, ptr_IDX			; is HL or indexs?
			beql	10$					; branch if HL
			movzbl	(r10)[r11], r2		; else fetch offset d
			incw	r10
			addb2	r2, r1				; add offset d TODO: 2013 how is this wrapped >2^16
	10$:	addl3	r11, r1, r2			; cvt z80 address to vax
			brb		20$
	12$:	; its BC DE or IDX
			movl	ptr_BC[r3], r2		; get address of reg pair
			bbs		#0, r0, 20$			; branch if lower 8 bit reg
			brb		17$
	15$:	; its A reg
			movl	ptr_AF, r2			; get address of reg AF
	17$:	incl	r2					; move ptr to upper 8 bit reg
	20$:	movl	r2, r5				; src address in r5
	
			movb	(r5), (r4)
			brw		fetch
;-------------------------------------------------------------------
op10:
src2:		extzv	#1, #2, r0, r3		; get src reg pair addr
			cmpb	r3, #3				; is it (IDX) or A?
			bneq	12$					; branch if not
			bbs		#0, r0, 15$			; branch if reg A
			movzwl	@ptr_IDX, r1		; else is (HL) or (IX+d) or (IY+d)
			cmpl	r9, ptr_IDX			; is HL or indexs
			beql	10$					; branch if HL
			movzbl	(r10)[r11], r2		; else fetch offset d
			incw	r10
			addb2	r2, r1				; add offset d
	10$:	addl3	r11, r1, r2			; cvt z80 address to vax
			brb		20$
	12$:	; its BC DE or IDX
			movl	ptr_BC[r3], r2		; get address of reg pair
			bbs		#0, r0, 20$			; branch if lower 8 bit reg
			brb		17$
	15$:	; its A reg
			movl	ptr_AF, r2			; get address of reg AF
	17$:	incl	r2					Ô move ptr to upper 8 bit reg
	20$:	movl	r2, r5				; src address in r5
			movzbl	(r5), r3
			
add_r3toA:	extzv	#3, #3, r0, r2
			caseb	r2, #0, #7
	10$:		.word	op10_000-10$	; ADD A, r
				.word	op10_001-10$	; ADC A, r
				.word	op10_010-10$	; SUB A, r
				.word	op10_011-10$	; SBC A, r
				.word	op10_100-10$	; AND A, r
				.word	op10_101-10$	; XOR A, r
				.word	op10_110-10$	; OR  A, r
				.word	op10_111-10$	; CP  A, r
				
op10_000:								; ADD A, r
			bicb2	#^xD7, reg_F		; clear S,Z,H,V,N,C
			bsbw	addr3toA			; add r3 to A
			brw		fetch
			
op10_001:								; ADC A, r
			bicb2	#^xD7, reg_F		; clear S,Z,H,V,N,C
			blbc	reg_F, 10$			; branch if NC
			movl	r3, r7				; save r3
			movzbl	#1, r3
			bsbw	addr3toA
			movl	r7, r3
	10$:	bsbw	addr3toA
			brw		fetch
			
op10_010:								; SUB A, r
			bisb2	#^x02, reg_F		; set N_flags
			bicb2	#^xD5, reg_F		; clear S,Z,H,V,C flags
			bsbw	subr3toA
			brw		fetch
			
op10_011:								; SBC A, r
			bisb2	#^x02, reg_F		; set N flags
			bicb2	#^xD5, reg_F		; clear S,Z,H,V,C flags
			blbc	reg_F, 10$			; branch NC
			movl	r3, r7				; save r3
			movzbl	#1, r3
			bsbw	subr3toA
			movl	r7, r3
	10$:	bsb		subr3toA
			brw		fetch
			
addr3toA:								; subroutine to add r3 to reg_A
			extzv	#0, #4, r3, r4		; get lower nibble in r3
			extzv	#0, #4, reg_A, r6	; get lower nibble of A in r6
			addb2	r4, r6				; add lower nibbles
			cmpb	r6, #^x0F
			bleq	no_H1				; branch if no Half Carry
			bisb2	#^x10, reg_F		; set H_flag
	no_H1:
			addb2	r3, reg_A			; do add set vax flags
			movpsl	r2
			blbc	r2, 31$
			bisb2	#^x01, reg_F		; set C flag
	31$:	bbc		#1, r2, 32$
			bisb2	#^x04, reg_F		; set V flag
	32$:	bbc		#2, r2, 33$
			bisb2	#^x40, reg_F		; set Z flag
	33$:	bbc		$3, r2, 34$
			bisb2	#^x80, reg_F		; set S flag
	34$:	rsb
	
subr3toA:								; subroutine to sub r3 to reg_A
			extzv	#0, #4, r3, r4		; get lower nibble in r3
			extzv	#0, #4, reg_A, r6	; get lower nibble of A in r6
			subb2	r4, r6				; sub lower nibbles
			cmpb	r6, #^x0F
			bleq	no_H2				; branch if no Half Carry
			bisb2	#^x10, reg_F		; set H_flag
	no_H2:
			subb2	r3, reg_A			; do sub set vax flags
			movpsl	r2
			blbc	r2, 31$
			bisb2	#^x01, reg_F		; set C flag
	31$:	bbc		#1, r2, 32$
			bisb2	#^x04, reg_F		; set V flag
	32$:	bbc		#2, r2, 33$
			bisb2	#^x40, reg_F		; set Z flag
	33$:	bbc		$3, r2, 34$
			bisb2	#^x80, reg_F		; set S flag
	34$:	rsb
	
op10_100:								; AND A, r
			bisb2	#^x10, reg_F		; set H
			bicb2	#^xC7, reg_F		; clear S, Z, P, N, C
			mcomb	r3, r3
			bicb2	r3, reg_A
logsetflags:
			movpsl	r2
			bbc		#2, r2, 33$
			bisb2	#^x40, reg_F		; set Z flag
	33$:	bbc		#3, r2, 34$
			bisb2	#^x80, reg_F		; set S flag
	34$:	movl	#7, r2
			clrl	r4
	40$:	bbc		r2, reg_A, 50$		; branch if bit not set
			mcoml	r4, r4				; toggle r3 on/off
	50$:	sobgeq	r2, 40$				; loop for 8 bits
			tstl	r4
			beql	60$
			bisb	#^x04, reg_F		; set P flag
	60$:	brw		fetch
	
op10_101:								; XOR A, r
			bicb2	#^xD7, reg_F		; clear S, Z, H, P, N, C
			xorb2	r3, reg_A
			brb		logsetflags
op10_110:								; OR A, r
			bicb2	#^D7, reg_F			; clear S,Z,H,P,N,C
			bisb2	r3, reg_A			; or reg_A with r3
			brb		logsetflags
			
op10_111:								; CP A, r
			bicb2	#^xD5, reg_F		; clear S,Z,H,P,C
			bisb2	#^x02, reg_F		; set N
			movb	reg_A, r7			; temp save reg_A
			bsbw	subr3toA			; sub neg(r3) to reg_A
			movb	r7, reg_A			; restore reg_A
			brw		fetch
;---------------------------------------------------------------
op11:
			;extzv	#0, #3, r0, r2 ; already done just after fetched:
			caseb	r2, #0, #7
	10$:		.word	op11_000-10$	; RET ccc
				.word	op11_001-10$	; POP rr, RET, EXX, PCHL, SPHL
				.word	op11_010-10$	; JP ccc, pq
				.word	op11_011-10$	; CB group, OUT, IN, EX (SP), HL, EX DE,HL,DI, EI
				.word	op11_100-10$	; CALL ccc, pq
				.word	op11_101-10$	; PUSH rr, CALL pq, DD IX, ED group, FD IY
				.word	op11_110-10$	; reg_A, n instructions
				.word	op11_111-10$	; RST
	FLGTBL:	.byte	6,0,2,7
	
op11_000:								; RET ccc
			extzv	#4, #2, r0, r2
			movzbl	FLGTBL[r2], r2		; get bit pos of flag
			bbs		#3, r0, 10$			; branch if set req
			bbc		r2, reg_F, 20$		; branch for RET
			brb		end_RET
	10$:	bbc		r2, reg_F, end_RET
	20$:
op_RET:
			movzwl	reg_SP, r2
			movb	(r2)[r11], TEMP_PC
			incw	r2
			movb	(r2)[r11], TEMP_PC+1
			incw	r2
			movw	r2, reg_SP
			movzwl	TEMP_PC, r10
 end_RET:	brw		fetch
 
 op11_001:								; POP rr, RET, EXX, PCHL, SPHL
 			extzv	#4, #2, r0, r2		; get register#
 			bbs		#3, r0, 50$			; branch if not POP rr
 			cmpb	r2, #3
 			bneq	10$					; branch if not AF reg
 			movl	ptr_AF, r3			; get dest address in r3
 			brb		20$					; branch if not AF reg
 	10$:	movl	ptr_BC[r2], r3		; get dest address in r3
 	20$:	movzwl	reg_SP, r2
 			movb	(r2)[r11], (r3)+
 			incw	r2
 			movb	(r2)[r11], (r3)
 			incw	r2
 			movw	r2, reg_SP
 			brw		fetch
 			
 	50$:	; r2 = op, 00=RET/ 01=EXX/ 10=JP (HL)/ 11=LD SP, HL
 			tstb	r2
 			beql	op_RET
 			cmpb	r2, #2
 			blss	op_EXX
 			beql	op_PCHL
 			;bgtr	op_SPHL
 			
op_SPHL:	movw	@ptr_IDX, reg_SP	; HL->SP
			brw		fetch
			
op_PCHL:	movw	@ptr_IDX, reg_SP	; HL->PC
			brw		fetch
			
op_EXX:		movl	reg_BC, r2			; BC,DE ->r2
			movw	reg_HL, r3			; HL->r3
			
			movl	reg_BC2, reg_BC		; BC2,DE2-> BC,DE
			movw	reg_HL2, reg_HL
			
			movl	r2, reg_BC2			; BC,DE -> BC2, DE2
			movw	r3, reg_HL2			; HL->HL2
			brw		fetch
			
op11_010:								; JP ccc, pq
			movb	(r10)[r11], TEMP_PC
			incw	r10
			movb	(r10)[r11], TEMP_PC+1
			incw	r10
			extzv	#4, #2, r0, r2
			movzbl	FLGTBL[r2], r2		; get bit pos of flag
			bbs		#3, r0, 10$			; branch if set req
			bbc		r2, reg_F, 20$		; branch for JMP
			brb		30$
	10$:	bbc		r2, reg_F, 30$		; branch if No JMP
	20$:	movw	TEMP_PC, r10		; do JMP
			brw		fetch
			
op11_011:	extzv	#3, #3, r0, r2
			caseb	r2, #0, #7
	10$:		.word op11_011_000-10$	; JP pq
				.word op11_011_001-10$	; CB group
				.word op11_011_010-10$	; OUT (n), A
				.word op11_011_011-10$	; IN A, (n)
				.word op11_011_100-10$	; EX (SP), HL
				.word op11_011_101-10$	; EX DE, HL
				.word op11_011_110-10$	; DI
				.word op11_011_111-10$	; EI
				
op11_011_000:							; JP pq
			movb	(r10)[r11], TEMP_PC
			incw	r10
			movb	(r10)[r11], TEMP_PC+1
			incw	r10
			movw	TEMP_PC, r10
			brw		fetch
			
;op11_011_001 see below this is the CB group

op11_011_010:							; OUT (n), A
			movzbl	(r10)[r11], r2		; fetch n
			incw	r10
			brw		fetch
			
op11_011_011:							; IN A, (n)
			movzbl	(r10)[r11], r2		; fetch n
			incw	r10
			clrb	reg_A				; return 0
			brw		fetch

op11_011_100:							; EX (SP), HL
			movzwl	reg_SP, r1			; get stack ptr
			movl	ptr_IDX, r2			; get address of index reg
			movb	(r2), r3
			movb	(r1)[r11], (r2)
			movb	r3, (r1)[r11]
			incw	r2
			incw	r1
			movb	(r2), r3
			movb	(r1)[r11], (r2)
			movb	r3, (r1)[r11]
			brw		fetch
			
op11_011_101:							; EX DE, HL
			movw	reg_DE, r2
			movw	@ptr_IDX, reg_DE
			movw	r2, @ptr_IDX
			brw		fetch
		
op11_011_110:							; DI
op11_011_111:							; DE
			nop
			brw		fetch
			
op11_011_001:							; CB group
			movzbl	(r10)[r11], r0		; fetch opcode
			incw	r10
			extzv	#1, #2, r0, r3		; get reg pair addr
			cmpb	r3, #3				; is it (IDX) or A
			bneq	12$					; branch if not
			blbs	r0, 15$				; branch if reg A
			movzwl	@ptr_IDX, r1		; else is (HL) or (IX+d) or (IY+d)
			cmpl	r9, ptr_IDX			; is HL or indexs?
			beql	10$					; branch if HL
			movzbl	(r10)[r11], r2		; else fetch offset d
			incw	r10
			addb2	r2, r1				; add offset d
	10$:	addl3	r11, r1, r2			; cvt z80 address to vax
			brb		20$
	12$:	; its BC, DE or IDX
			movl	ptr_BC[r3], r2		; get address of reg pair
			blbs	r0, 20$				; branch if lower 8 bit reg
			brb		17$
	15$:	; its A reg
			movl	ptr_AF, r2			; get address of reg AF
	17$:	incl	r2					; move ptr to upper 8 bit reg
	20$:	; r2 now points to reg
			extzv	#6, #2, r0, r5
			beql	reg_ops
			extzv	#3, #3, r0, r3
			movl	#1, r4
			ashl 	r3, r4, r4			; create bit mask in r4
			cmpb	r5, #2
			blss	op_BIT
			beql	op_RES
			;bgtr	op_SET
op_SET:		bisb2	r4, (r2)
			brw		fetch
			
op_RES:		bicb2	r4, (r2)
			brw		fetch
			
op_BIT:		bicb2	#^x42, reg_F		; clear Z, N
			bisb2	#^x10, reg_F		; set H
			bitb	r4, (r2)			; set bit
			beql	10$
			bisb2	#^x40, reg_F		; set Z flag
	10$:	brw		fetch
	
reg_ops:
			movzbl	(r2), r4
			bicb2	#^xD6, reg_F		; clear S,Z,H,P,N
			extzv	#3, #3, r0, r3		; get opcode
			caseb	r3, #0, #7
	10$:		.word opCB_00_000-10$	; RLC
				.word opCB_00_001-10$	; RRC
				.word opCB_00_010-10$	; RR
				.word opCB_00_011-10$	; RL
				.word opCB_00_100-10$	; SLA
				.word opCB_00_101-10$	; SRA
				.word fetch-10$			; Not DEFINED opCB_00_110 
				.word opCB_00_111-10$	; SRL
				
opCB_00_000:							; RLC
			bicb2	#^x01, reg_F		; clear C
			ashl	#1, r4, r4
			bbc		#8, r4, 10$
			bisb2	#^x01, reg_F		; set C
			bisb2	#^x01, r4			; bit 8 -> bit 0
	10$:	brw		CBsetflags
	
	
opCB_00_001:							; RRC
			bicb2	#^x01, reg_F		; clear C
			blbc	r4, 10$
			bisb2	#^x01, reg_F		; set C bit0 -> C
			bisw2	#^x100, r4			; set bit8 to bit0
	10$:	ashl	#-1, r4, r4
			brw		CBsetflags
			
opCB_00_010:							; RL
			ashl	#1, r4, r4
			blbc	reg_F, 10$			; branch NC
			bisb2	#^x01, r4			; C->bit 0
	10$:	bicb2	#^x01, reg_F		; clear C
			bbc		#8, r4, 20$
			bisb2	#^x01, reg_F
	20$:	brb		CBsetflags

opCB_00_011:							; RR
			blbc	reg_F, 10$			; branch NC
			bisbw2	#^x100, r4			; set bit8 C -> bit8
	10$:	blbc	r4, 20$
			bisb2	#^x01, reg_F		; set C flag
	20$:	ashl	#-1, r4, r4
			brb		CBsetflags
			
opCB_00_100:							; SLA
			bisb2	#^x01, reg_F		; clear C
			ashl	#1, r4, r4
			bbc		#8, r4, 10$
			bicb2	#^x01, reg_F		; bit7 ->C
			bisb2	#^x01, reg_F
	10$:	brb		CBsetflags
	
opCB_00_101:							; SRA
			bisb2	#^x01, reg_F		; clear C
			blbc	r4, 10$
			bisb2	#^x01, reg_F		; bit0 ->C
	10$:	bbc		#7, r4, 20$
			bisw2	#^x100, r4			; bit7 ->bit8
	20$:	ashl	#-1, r4, r4			; shift right 1
			brb		CBsetflags
			
opCB_00_111:							; SRL
			bicb2	#^x01, reg_F		; clear C
			blbc	r4, 10$
			bicb2	#^x01, reg_F		; bit0 ->C
	10$:	ashl	#1, r4, r4
			;brb 	CBsetflags
			
CBsetflags:	; set S, Z, P
			movb	r4, (r2)
			beql	10$
			bisb2	#^x40, reg_F		; set Z flag
	10$:	bbc		#7, r4, 20$
			bisb2	#^x80, reg_F		; set S flag
	20$:	clrl	r3
			movl	#7, r2
	40$:	bbc		r2, r4, 50$
			mcoml	r4, r4				; toggle r4 on/off
	50$:	sobgeq	r2, 40$
			tstl	r4
			beql	60$
			bisb2	#^x04, reg_F		; set P flag
	60$:	brw		fetch
	
op11_100:								; CALL ccc, pq
			movb	(r10)[r11], TEMP_PC
			incw	r10
			movb	(r10)[r11], TEMP_PC+1
			incw	r10
			extzv	#4, #2, r0, r2
			movzbl	FLGTBL[r2], r2		; get bit pos of flag
			bbs		#3, r0, 10$			; branch if set req
			bbc		r2, reg_F, 20$		; branch for JMP
			brw		fetch
	10$:	bbs		r2, reg_F, 20$		; branch for JMP
			brw		fetch
	20$:
endcall:	movw	reg_SP, r2
			movw	r10, TEMP
			movw	TEMP_PC, r10		; doJMP
			decw	r2					; sp-1
			movb	TEMP+1, (r2)[r11]	; push Ret addr LOW
			decw	r2					; sp-1
			movw	TEMP, (r2)[r11]		; push Ret addr HIGH
			movw	r2, reg_SP
			brw		fetch
			
op11_101:
			extzv	#4, #2, r0, r2		; get register#
			bbs		#3, r0, 50$			; branch if not PUSH rr
			cmpb	r2, #3				; is it AF
			bneq	10$					; branch if not AF
			movl	ptr_AF, r3			; get address of register in r3
			brb		20$
	10$:	movl	ptr_BC[r2], r3		; get address of register in r3
	20$:	movzwl	reg_SP, r2
			decw	r2
			movb	b^1(r3), (r2)[r11]	; High register to stack
			decw	r2
			movb	   (r3), (r2)[r11]  ; Low register to stack
			movw	r2, reg_SP
			brw		fetch
	50$:	beql	op_CALL
			cmpb	r2, #2
			blss	op_DD				; use IX
			beql	op_ED				; ED group
			;bgtr	op_FD				; use IY

op_FD:									; use IY
			movaw	reg_IY, ptr_IDX
			brw		fetch2
op_DD:									; use IX
			movaw	reg_IX, ptr_IDX
			brw		fetch2

op_CALL:	movb	(r10)[r11], TEMP_PC
			incw	r10
			movb	(r10)[r11], TEMP_PC+1
			incw	r10
			brw		endcall
			
op_ED:									; ED group
			movzbl	(r10)[r11], r0		; fetch op code
			incw	r10
			extzv	#0, #3, r0, r3
			extzv	#6, #2, r0, r2
			beql	opED_00
			cmpb	r2, #2
			blss	opED01
			beql	opED10
			bgtr	opED_11
opED_00:
			brw		fetch				; NOP
opED01:		brw		opED_01
opED10:		brw		opED_10

opED_11:
			extzv	#0, #6, r0, r3
			caseb	r3, #0, #9
	10$:		.word	const=10$		; C0
				.word	conout-10$		; C1
				.word	diskio-10$		; C2
				.word	diskio-10$		; C3
				.word	read_rdr-10$	; C4
				.word	write_pun-10$	; C5
				.word	write_lpt-10$	; C6
				.word	flash-10$		; C7
				.word	OFFLOAD-10$		; C8 DISKIO BC BYTES
				.word	BLOCKWRITE-10$	; C9 DISKIO BC BYTES
			brw	fetch					; NOP 
				
			
	
diskio:
			movwl	reg_HL, r1
			addl3	r1, r11, r8
			$RAB_STORE	rab=drive_A$RAB	,-
						RBF=(r8)		,-
						UBF=(r8)		; set buff address
			movzbl	reg_D, r2			; Trk no
			movzbl	reg_E, r4			; sec no
			mull2	#REC128_TRK, r2		; trks * sec/trk
			addl3	r2, r4, rec_no
			$FIND	drive_A$RAB
			bsbw	error
			cmpb	r3, #2
			beql	readtdse
			;blss	writetdse
writetdse:
			$UPDATE	drive_A$RAB
			bsbw	error
			bisb2	#^x40, reg_F		; ret Z true
			clrb	reg_A
			brw		op_RET
			
readtdse:
			$GET	drive_A$RAB
			bsbw	error
			bisb2	#^x40, reg_F		; ret Z true
			clrb	reg_A
			brw		op_RET
			
read_rdr:
			tstw	rdr$FAB+FAB$W_IFI	; is the file open
			bneq	10$					; branch if yes
			$OPEN	rdr$FAB
			bsbw	error
			$CONNECT rdr$RAB
			bsbw	error
			clrw	rdrptr
	10$:	cmpw	rdrptr, rdr$RAB+RAB$W_RSZ
			blss	15$					; branch if not end of buffer
			$GET	rdr$RAB
			bsbw	error
			clrw	rdrptr
	15$:
			movzwl	rdrptr, r0
			bicb2	#^x40, reg_F		; set NZ flag always a char
			movb	rdr$rec[r0], reg_A
			incw	rdrptr
			cmpb	reg_A, #^x1a		; is it control-Z ie EOF ?
			bneq	20$
			$CLOSE	rdr$FAB
			bsbw	error
	20$:	brw		op_RET
	
write_pun:
			tstw	pun$FAB+FAB$W_IFI	; is the file open
			bneq	10$
			$CREATE	pun$FAB
			bsbw	error
			$CONNECT pun$RAB
			bsbw	error
			clrw	punptr
	10$:
			movzwl	punptr, r0
			bicb2	#^x40, reg_F		; set NZ flag always a char
			movb	reg_A, pun$rec[r0]
			incw	punptr
			cmpb	reg_A, #^x0a		; is it control-Z ie EOF?
			bneq	20$
			$CLOSE	pun$FAB
			bsbw	error
	20$:	brw		op_RET

write_lpt:
			tstw	lpt$FAB+FAB$W_IFI	; is the file open?
			bneq	10$
			$CREATE	lpt$FAB
			bsbw	error
			$CONNECT lpt$RAB
			bsbw	error
			clrw	lptptr
	10$:
			movzwl	lptptr, r0
			bicb2	#^x40, reg_F		; set NZ flag always a char
			movb	reg_A, lpt$rec[r0]
			incw	lptptr
			cmpb	reg_A, #^x0a		; is it LF
			bneq	15$
			$PUT	lpt$TAB
			bsbw	error
			clrw	lptptr
	15$:	cmpb	reg_A, #^x1a		; is it control-Z ie EOF?
			bneq	20$
			$CLOSE	lpr$FAB
			bsbw	error
	20$:	brw		op_RET
	
	
flash:
; put top of screen in reverse video message at (HL) last char high bit set
			movb	#^x1b, reg_C
			bsbb	outchar
			movb	#^a/[/, reg_C
			bsbb	outchar			
			movb	#^a/0/, reg_C
			bsbb	outchar
			movb	#^a/;/, reg_C
			bsbb	outchar
			movb	#^a/5/, reg_C
			bsbb	outchar
			movb	#^a/;/, reg_C
			bsbb	outchar
			movb	#^a/7/, reg_C
			bsbb	outchar
			movb	#^a/m/, reg_C
			bsbb	outchar

			movzwl	reg_HL, r5
	10$:	movzbl	(r5)[r11], r4
			incw	r5
			bicb3	#^x80, r4, reg_C
			bsbb	outchar
			bbc		#7, r4, 10$
			
			movb	#^x1b, reg_C
			bsbb	outchar
			movb	#^a/[/, reg_C
			bsbb	outchar			
			movb	#^a/0/, reg_C
			bsbb	outchar
			movb	#^a/m/, reg_C
			bsbb	outchar
			
			brw		op_RET
			
outchar:
			$QIOW_S	efn=#2				,-
					func=#IO$_WRITEVBLK	,-
					char=TT_CHAN		,-
					iosb=TT_IOSB		,-
					p1=reg_C			,-
					p2=#1
			rsb
			
BLOCKWRITE:
			movzbl	reg_D, r2			; Trk no
			movzbl	reg_E, r3			; sec no
			mull2	#REC128_TRK, r2		; trks * sec/trk
			addl3	r2, r3, rec_no
			movzwl	reg_BC, r1			; get num bytes to write
			divl3	#128, r1, r2		; r2 = num full sectors
			mull3	#128, r2, r3
			subl3	r3, r1, r4			; remainder in r4
			movzwl	reg_HL, r5
			
	10$:	addl3	r5, r11, r8
			$RAB_STORE	rab=drive_A$RAB		,-
						RBF=(r8)			,-
						UBF=(r8)		; set buff address
						
			$FIND	drive_A$RAB
			bsbw	error
			$UPDATE	drive_A$RAB
			bsbw	error
			addw2	#128, r5
			incl	rec_no
			sobgtr	r2, 10$				; loop for number of ull sectors
			tstl	r4
			beql	20$
			$RAB_STORE	rab=drive_A$RAB		,-
						RBF=drivea_rec		,-
						UBF=drivea_rec	; set buff address
						
			movc5	r4, (r5)[r11], #^x1a, #128, drivea_rec
			$FIND	drive_A$RAB
			bsbw	error
	20$:	
			bisb2	#^x40, reg_F		; set Z true
			clrb	reg_A
			brw		op_RET
			
			
OFFLOAD:	; read BC bytes from TRK D SEC E to (HL)
			movzbl	reg_D, r2			; Trk no
			movzbl	reg_E, r3			; sec no
			mull2	#REC128_TRK, r2		; trks * sec/trk
			addl3	r2, r3, rec_no
			movzwl	reg_BC, r1			; get num bytes to write
			divl3	#128, r1, r2		; r2 = num full sectors
			mull3	#128, r2, r3
			subl3	r3, r1, r4			; remainder
			movzwl	reg_HL, r5
			
	10$:
			addl3	r5, r11, r8
			$RAB_STORE	rab=drive_A$RAB	,-
						RBF=(r8)		,-
						UBF=(r8)		; set buff address
			
			$FIND	drive_A$RAB
			bsbw	error
			$GET	drive_A$RAB
			bsbw	error
			addw2	#128, r5
			incl	rec_no
			sobgtr	r2, 10$				; loop for number of full sectors
			
			tstl	r4
			beql	20$
			$RAB_STORE	rab=drive_A$RAB	,-
						RBF=drivea_rec	,-
						UBF=drivea_rec	; set buffer address
			$FIND	drive_A$RAB
			bsbw	error
			$GET	drive_A$RAB
			bsbw	error
			movc3	r4, drivea_rec, (r5)[r11]
	20$:
			bisb2	#^x40, reg_F		; set Z true
			clrb	reg_A
			brw		op_RET

opED_01:
			caseb	r3, #0, #7
	10$:		.word	opED_01_000-10$	; IN	r, (C) & tstport(C)
				.word	opED_01_001-10$	; OUT	r, (C)
				.word	opED_01_010-10$	; SBC	ADC 16bit HL, rr
				.word	opED_01_011-10$	; LD	(pq), rr LD rr, (pq)
				.word	opED_01_100-10$	; NEG reg_A
				.word	opED_01_101-10$	; RETN RETI
				.word	opED_01_110-10$	; IM0 IM1 IM2
				.word	opED_01_111-10$	; LD IorR , A LD a, IorR RRD A RLDA
				
opED_01_000:							; IN r, (C)
			extzv	#4, #2, r0, r3		; get register
			cmpb	r3, #3				; is it tst only
			bneq	5$
			bbs		#3, r0, 10$			; branch if reg_A
			movab	TEMP, r2			; store result to be lost
			brb		20$
	5$:		movl	ptr_BC[r3], r2
			bbs		#3, r0, 20$
			brb		15$
	10$:	movl	ptr_AF, r2
	15$:	incl	r2
	20$:
			clrb	(r2)				; return 0
			bicb2	#^xD6, reg_F		; clear S,Z,H,P,N
			brw		fetch
			
opED_01_001:							; OUT (C), r
			extzv	#4, #2, r0, r3		; get register
			cmpb	r3, #3				; is it tst only
			bneq	5$
			bbs		#3, r0, 10$			; branch if reg_A
			movab	TEMP, r2			Ô store result to be lost
			brb		20$
	5$:		movl	ptr_BC[r3], r2
			bbs		#3, r0, 20$
			brb		15$
	10$:	movl	ptr_AF, r2
	15$:	incl	r2					; select lower reg of pair
	20$:
			brw		fetch
			
opED_01_010:							; SBC HL, rr  ADC HL, rr
;NOTE: Half carry/borrow bit 11. I have not supported setting H flag for this event. TODO: 2013 WTFnot

			extzv	#4, #2, r0, r2
			movl	ptr_BC[r2], r2
			bbs		#3, r0, op_ADCHL
op_SBCHL:
			sbwc	(r2), @ptr_IDX
			brb		opED_Csetflags
op_ADCHL:
			adwc	(t2), @ptr_IDX

opED_Csetflags:
			movpsl	r2
			bicb2	#^xD7, reg_F		; clear S,Z,H,V,N,C
			blbc	r2, 10$
			bisb2	#^x01, reg_F		; set C flag
	10$:	bbc		#1, r2, 20$
			bisb2	#^x04, reg_F		; set V flag
	20$:	bbc		#3, r2, 30$
			bisb2	#^x40, reg_F		; set Z flag
	30$:	bbc		#3, r2, 40$
			bisb2	#^x80, reg_F		; set S flag
	40$:	brw		fetch
	
	
opED_01_011:							; LD (pq), rr  LD rr, (pq)
			movb	(r10)[r11], TEMP	; fetch pq
			incw	r10
			movb	(r10)[r11], TEMP+1
			incw	r10
			extzv	#4, #2, r0, r2		; get reg #
			movl	ptr_BC[r2], r2		; get address of reg in r2
			movw	TEMP, r1
			addl3	r11, r1, r3			; make vax relative
			bbs		#3, r0, opLDrrpq
opLDpqrr:
			movb	(r2)+, (r3)
			incw	r3
			; TODO: consider that (r2)+ should be an incw?
			
			movb	(r3), (r2)
			brw		fetch
opLDrrpq:
			movb	(r3), (r2)+
			incw	r3
			movb	(r3), (r2)
			brw		fetch
			
opED_01_100:							; NEG A
			cmpb	r0, #^x44
			bneq	10$
			bicb2	#^xD5, reg_F		; clear S,Z,H,V,C
			bisb2	#^x02, reg_F		; set N flag
			extzv	#0, #4, reg_A, r2
			mnegb	r2, r2
			cmpb	r2, #^x0f
			beql	10$					; branch if no H
			bisb2	#^x10, reg_F		; set H flag
	10$:	mnegb	reg_A, reg_A
			movpsl	r2
			blbc	r2, 20$
			bisb2	#^x01, reg_F		; set C flag
	20$:	bbc		#1, r2, 30$
			bisb2   #^x04, reg_F		; set V flag
	30$:	bbc		#2, r2, 40$
			bisb2	#^x40, reg_F		; set Z flag
	40$:	bbc		#3, r2, 50$
			bisb2	#^x80, reg_F		; set S flag
	50$:	brw		fetch
	
opED_01_101:
			cmpb	r0, #^x45
			beql	10$					; RETN
			cmpb	r0, #^x4D
			beql	10$					; RETI
			brw		fetch				; NOP all else
	10$:	brw		op_RET

opED_01_110:							; IM0, IM1, IM2
			brw		fetch				; NOP
			
opED_01_111:
			extzv	#3, #3, r0, r2
			caseb	r2, #0, #5
	10$:		.word opED_01_111_000-10$	; LD I,A
				.word opED_01_111_001-10$	; LD R,A
				.word opED_01_111_010-10$	; LD A,I
				.word opED_01_111_011-10$	; LD A,R
				.word opED_01_111_100-10$	; RRD A
				.word opED_01_111_101-10$	; RLD A
			brw	fetch						; NOP 110 & 111

opED_01_111_000:							; LD I,A
			movb	reg_A, reg_I
			brw		fetch
			
opED_01_111_001:							; LD R, A
			movb	reg_A, reg_R
			brw		fetch
		
opED_01_111_010:							; LD A, I
			movb	reg_I, reg_A
	ISET:	bicb2	#^xD6, reg_F			; clear S,Z,H,V,N
			tstb	reg_A
			beql	10$
			bisb2	#^x40, reg_F			; set Z flag
	10$:	bbc		#6, reg_A, 20$
			bisb2	#^x80, reg_F			; set S flag
	20$		brw		fetch
	
opED_01_111_011:							; LD A, R
			movb	reg_R, reg_A
			brb		ISET
			
opED_01_111_100:							; RRD A
			bicb2	#^xD6, reg_F			; clear S,Z,H,P,N
			movzwl	reg_HL, r1
			addl3	r1, r11, r8				; make vax relative
			extzv	#0, #4, reg_A, r2		; Lnibble A
			extzv	#0, #4, (r8), r3		; Lnibble (HL)
			extzv	#4, #4, (r8), r4		; Hnibble (HL)
			clrb	(r8)
			bicb2	#^x0F, reg_A			; clear Lnibble A
;1
			bisb2	r3, reg_A				; Lnibble (HL) -> Lnibble A
			bisb2	r4, (r8)				; Hbibble (HL) -> Lnibble (HL)
			ashl	#4, r2, r2				; Lnibble  A  shifted left 4 bits
			bisb2	r2, (r8)				; Lnibble  A -> Hnibble (HL)
;4
			tstb	reg_A
			movpsl	r2
			bneq	10$
			bisb2	#^x40, reg_F			; set Z flag
	10$:	bbc		#3, r2, 20$
			bisb2	#^x80, reg_F			; set S flag
	20$:	movzbl	reg_A, r4				; P flag
			clrl	r3
			movl	#7, r2
	40$:	bbc		r2, r4, 50$
			mcoml	r4, r4					; toggle r4 on/off
	50$:	sobgeq	r2, 40$					; loop for 8 bits
			tstl	r4
			beql	60$
			bisb2	#^x04, reg_F			; set P flag
	60$:	brw		fetch
	
opED_01_111_101:							; RLD A
			bicb2	#^xD6, reg_F			; clear S,Z,H,P,N
			movzwl	reg_HL, r1
			addl3	r1, r11, r8				; make vax relative
			extzv	#0, #4, reg_A, r2		; Lnibble A
			extzv	#0, #4,  (r8), r3		; Lnibble (HL)
			extzv	#4, #4,  (r8), r4		; Hnibble (HL)
			clrb	(r8)
			bicb2	#^x0F, reg_A			; clear Lnibble A
;1
			bisb	r4, reg_A				; Hnibble (HL) -> Lnibble A
			ashl	#4, r3, r3				; Lnibble (HL) left shift 4 bits
			bisb3	r2, r3, (r8)			; Lnibble A -> Lnibble (HL)
											; && Lnibble (HL) -> Hnibble (HL)
;4
			tstb	reg_A
			movpsl	r2
			bneq	10$
			bisb2	#^x40, reg_F
	10$:	bbc		#3, r2, 20$
			bisb2	#^x80, reg_F			; set S flag
	20$:	movzbl	reg_A, r4				; P flag
			clrl	r3
			movl	#7, r2
	40$:	bbc		r2, r4, 50$
			mcoml	r4, r4					; toggle r4 on/off
	50$:	sobgeq	r2, 40$					; loop for 8 bits
			tstl	r4
			beql	60$
			bisb2	#^x04, reg_F			; set P flag
	60$:	brw		fetch
			brw		fetch					; ?2013 odd
		
;===
opED_10:									; block ops
			bisb2	#^x16, reg_F			; clear H,V,N
			movzwl	@ptr_IDX, r1			; src
			movzwl	reg_DE,   r4			; dst
			extzv	#3, #3, r0, r3
			extzv	#0, #3, r0, r2
			beql	op_LD
			cmpb	r2, #01
			bneq	opCP
			brw		fetch					; all else is NOP
opCP:		brw		op_CP
op_LD:		case	r3, #4, #7
	10$:		.word op_LD_100-10$			; Blk Inc
				.word op_LD_101-10$			; Blk Dec
				.word op_LD_110-10$			; Blk Inc Repeat
				.word op_LD_111-10$			; Blk Dec Repeat
			brw	fetch

; TODO: 2013 - 24years on this loops like rubish not indexing  the movb			
op_LD_100:									; LDI
			movb	(r1)[r11], (r2)[r11]
			incw	@ptr_IDX
			incw	reg_DE
			decw	reg_BC
			beql	10$
			bisb2	#^x04, reg_F			; set V flag
	10$:	brw		fetch
	
op_LD_110:									; LDIR
	10$:	movb	(r1)[r11], (r2)[r11]
			incw	@ptr_IDX
			incw	reg_DE
			decw	reg_BC
			beql	10$
			bisb2	#^x04, reg_F			; set V flag
			brw		fetch
			
op_LD_101:									; LDD
			movb	(r1)[r11], (r2)[r11]
			decw	@ptr_IDX
			decw	reg_DE
			decw	reg_BC
			beql	10$
			bisb2	#^x04, reg_F			; set V flag
	10$:	brw		fetch

op_LD_111:									; LDDR
	10$:	movb	(r1)[r11], (r2)[r11]
			decw	@ptr_IDX
			decw	reg_DE
			decw	reg_BC
			beql	10$
			bisb2	#^x04, reg_F			; set V flag
			brw		fetch

op_CP:
			bicb2	#^xD4, reg_F			; clear S,Z,H,V
			bisb2	#^x02, reg_F			; set N flag
			caseb	r3, #4, #7
	10$:		.word	op_CP_100-10$		; CPI
				.word	op_CP_101-10$		; CPD
				.word	op_CP_110-10$		; CPIR
				.word	op_CP_111-10$		; CPDR
			brw		fetch
			
op_CP_100:									; CPI
			movzwl	@ptr_IDX, r1
			movzbl	(r1)[r11], r3
			movb	reg_A, r7				; temp save reg_A
			bsbw	subr3toA				; add neg(r3) to reg_A
			movb	r7, reg_A				; restore reg_A
			incw	@ptr_IDX
			decw	reg_BC
			bneq	10$
			bisb2	#^x04, reg_F			; set V flag
	10$:	brw		fetch
	
op_CP_110:									; CPIR
	10$:	movzwl	@ptr_IDX, r1
			movzbl	(r1)[r11], r3
			movb	reg_A, r7				; temo save reg_A
			bsbw	subr3toA				; sub r3 from reg_A
			movb	r7, reg_A				; restore reg_A
			incw	@ptr_IDX
			decw	reg_BC
			bneq	10$
			bisb2	#^x04, reg_F			; set V flag
			brw		fetch
			
op_CP_101:									; CPD
			movzwl	@ptr_IDX, r1
			movzbl	(r1)[r11], r3
			movb	reg_A, r7				; temp save reg_A
			bsbw	subr3toA				; sub r3 from reg_A
			movb	r7, reg_A				; restore reg_A
			decw	@ptr_IDX
			decw	reg_BC
			bneq	10$
			bisb2	#^x04, reg_F			; set V flag
	10:$	brw		fetch
	
op_CP_111:									; CPDR
	10$:	movzwl	@ptr_IDX, r1
			movzbl	(r1)[r11], r3
			movb	reg_A, r7				; temp save reg_A
			bsbw	subr3toA				; sub r3 from reg_A
			movb	r7, reg_A				; restore reg_A
			decw	@ptr_IDX
			decw	reg_BC
			bneq	10$
			bisb2	#^x04, reg_F			; set V flag
			brw		fetch
			
			
;-------------
op11_110:									; ADD a, n
			movzbl	(r10)[r11], r3			; fetch n
			incw	r10
			brw		add_r3toA
			
op11_111:									; RST
			movzwl	reg_SP, r1
			movw	r10, TEMP_PC
			decw	r1
			movb	TEMP_PC, (r1)[r11]
			decw	r1
			movb	TEMP_PC+1, (r1)[r11]
			movw	r1, reg_SP
			extzv	#3, #3, r0, r2
			ashl	#3, r2, r10
			brw		fetch
			
SETUPIO:
			movb	#^xFF, l^save_key(r11)	; set l^save_key(r11) to -1
			$ASSIGN_S	chan=tt_chan	,-
						devnam=tt_nam
			bsbw	error
			
			$OPEN	drive_A$FAB
			bsbw	error
			$CONNECT drive_A$RAB
			bsbw	error
;
			$OPEN	boot$FAB
			bsbw	error
			$CONNECT boot$RAB
			bsbw	error
			movab	bootrec, r9
	10$:
			clrl	r8
			$GET	boot$RAB
			cmpl	r0, #RMS$SUC
			bneq	end_load
			cmpb	(r8)+[r9], #^A/:/
			bneq	10$
			bsbw	get_hex			; get length byte
			movl	r0, r7
			bsbw	get_hex			; get load address
			movb	r0, TEMP+1
			bsbw	get_hex
			movb	r0, TEMP
			movzwl	TEMP, r10
	20$:
			bsbw	get_hex
			movb	r0, (r10)[r11]
			incw	r10
			sobgtr	r7, 20$			; loop for length
			incl	r8				; ignore checksum byte
			incl	r8
			brw		10$				; get next record
			
end_load:
			clrl	r10				; PC start address
			$CLOSE	boot$FAB
			rsb
	
get_hex:
			; get byte from ascii test at address W^bootrec(r8)
			movzbl	(r8)+[r9], r0
			subl2	#^A/0/, r0
			cmpl	r0, #<^A/A/-^A/0/>  ; 2013-is this right?
			blss	20$					; branch if 0 .. 9
			bicb2	#^x20, r0			; upcase
			cmpl	r0, #<^A/F/-^A/0/>
			bleq	10$					; branch if A .. F
			clrl	r0					; error return 0
			rsb
	10$:	subl2	#7, r0
	20$:
			movzbl	(r8)+[r9], r1
			subl2	#^A/0/, r1
			cmpl	r1, #<^A/A/-^A/0/>
			blss	40$					; branch if 0 .. 9
			bicb2	#^x20, r1			; upcase
			cmpl	r1, #<^A/F/-^A/0/>
			bleq	30$					; branch if A .. F
			clrl	r0					; error retunr 0
			rsb
	30$:	subl2	#7, r1
	40$:
			mull2	#16, r0
			addl2	r1, r0
			rsb
			
const:
			cmpb	l^save_key(r11), #^xFF
			bneq	10$					; branch if char in buf
			tstb	qio_flag
			bneq	5$
			movb	#^xFF, l^save_key(r11)
			movb	#^xFF, qio_flag
			$QIO_S	efn=#1							,-
					func=#IO$_READVBLK!IO$M_NOECHO	,-
					chan=TT_CHAN					,-
					iosb=TT_IOSB					,-
					p1=l^save_key(r11)				,-
					p2=#1							; request getch
			bsbw	error
			
	5$:		cmpb	l^save_key(r11), #^xFF	; did we get a char?
			beql	20$					; branch yes
	10$:	movb	#^xFF, reg_A		; tell them we got a char
			bicb2	#^x40, reg_F		; clear Z flag
			clrb	qio_flag			; qio must  have completed
			brb		30$
			
	20$:	clrb	reg_A				; tell them no char
			bisb2	#^x40, reg_F		; set Z flag
	30$:
			brw		op_RET
			
conout:
			$QIOW_S	efn=#2				,-
					func=#IO$_WRITEVBLK	,-
					chan=TT_CHAN		,-
					iosb=TT_IOSB		,-
					p1=reg_C			,-
					p2=#1
			bsbw	error
			brw		op_RET
			
error:
			blbs	r0, 10$
			$exit_s	r0
	10$:
			rsb
			
halt_message:
			$CREATE	out$FAB
			bsbw	error
			$CONNECT out$RAB
			bsbw	error
			
			movzwl	reg_SP , -(sp)
			movzwl	reg_IY , -(sp)
			movzwl	reg_IX , -(sp)
			movzwl	reg_HL2, -(sp)
			movzwl	reg_HL , -(sp)
			movzwl	reg_DE2, -(sp)
			movzwl	reg_DE , -(sp)
			movzwl	reg_BC2, -(sp)
			movzwl	reg_BC , -(sp)
			movzwl	reg_AF2, -(sp)
			movzwl	reg_AF , -(sp)

			subw3	#1, r10, r0     ; ZPC=R10
			pushl	r0				; OC
			pushaq	outbuf			; outbuf by desc
			pushaw	out$RAB + RAB$W_RSZ;
			pushaq	hlt_mess		; ctrstr by desc
			calls	#15, g^sys$fao
			
			$PUT	out$RAB
			bsbw	error
			$CLOSE out$FAB
			bsbw	error
end_halt:							; for debug break
            movc3   #halt_prompt_len, halt_prompt, outbuf
            movl    #halt_prompt_len, out$RAB+ RAB$W_USZ
            $PUT    out$RAB
            bsbw    error
            bsbw    getc
; TODO: finish this addition of prompting to continue during halt
			brw	fetch
			
close_IO:
			$DASSGN_S	chan=tt_chan
			$CLOSE		drive_A$TAB
			bsbw	error
			movl	s^#SS$_NORMAL, r0
			ret		; exit to VMS
			
			.end z80_start
